{"version":3,"file":"index.js","sources":["../../src/History.ts","../../src/useMethods.ts","../../src/getRandomId.ts","../../src/EventHandlers/ConnectorRegistry.ts","../../src/EventHandlers/interfaces.ts","../../src/EventHandlers/EventHandlers.ts","../../src/EventHandlers/isEventBlockedByDescendant.ts","../../src/EventHandlers/wrapConnectorHooks.tsx","../../src/RenderIndicator.tsx","../../src/platform.ts","../../src/constants.ts","../../src/EventHandlers/DerivedEventHandlers.ts","../../src/deprecate.ts","../../src/getDOMInfo.ts","../../src/useCollector.tsx","../../src/useEffectOnce.tsx"],"sourcesContent":["import { Patch, applyPatches } from 'immer';\n\ntype Timeline = Array<{\n  patches: Patch[];\n  inversePatches: Patch[];\n  timestamp: number;\n}>;\n\nexport const HISTORY_ACTIONS = {\n  UNDO: 'HISTORY_UNDO',\n  REDO: 'HISTORY_REDO',\n  THROTTLE: 'HISTORY_THROTTLE',\n  IGNORE: 'HISTORY_IGNORE',\n  MERGE: 'HISTORY_MERGE',\n  CLEAR: 'HISTORY_CLEAR',\n};\n\nexport class History {\n  timeline: Timeline = [];\n  pointer = -1;\n\n  add(patches: Patch[], inversePatches: Patch[]) {\n    if (patches.length === 0 && inversePatches.length === 0) {\n      return;\n    }\n\n    this.pointer = this.pointer + 1;\n    this.timeline.length = this.pointer;\n    this.timeline[this.pointer] = {\n      patches,\n      inversePatches,\n      timestamp: Date.now(),\n    };\n  }\n\n  throttleAdd(\n    patches: Patch[],\n    inversePatches: Patch[],\n    throttleRate: number = 500\n  ) {\n    if (patches.length === 0 && inversePatches.length === 0) {\n      return;\n    }\n\n    if (this.timeline.length && this.pointer >= 0) {\n      const {\n        patches: currPatches,\n        inversePatches: currInversePatches,\n        timestamp,\n      } = this.timeline[this.pointer];\n\n      const now = new Date();\n      const diff = now.getTime() - timestamp;\n\n      if (diff < throttleRate) {\n        this.timeline[this.pointer] = {\n          timestamp,\n          patches: [...currPatches, ...patches],\n          inversePatches: [...inversePatches, ...currInversePatches],\n        };\n        return;\n      }\n    }\n\n    this.add(patches, inversePatches);\n  }\n\n  merge(patches: Patch[], inversePatches: Patch[]) {\n    if (patches.length === 0 && inversePatches.length === 0) {\n      return;\n    }\n\n    if (this.timeline.length && this.pointer >= 0) {\n      const {\n        patches: currPatches,\n        inversePatches: currInversePatches,\n        timestamp,\n      } = this.timeline[this.pointer];\n\n      this.timeline[this.pointer] = {\n        timestamp,\n        patches: [...currPatches, ...patches],\n        inversePatches: [...inversePatches, ...currInversePatches],\n      };\n      return;\n    }\n\n    this.add(patches, inversePatches);\n  }\n\n  clear() {\n    this.timeline = [];\n    this.pointer = -1;\n  }\n\n  canUndo() {\n    return this.pointer >= 0;\n  }\n\n  canRedo() {\n    return this.pointer < this.timeline.length - 1;\n  }\n\n  undo(state) {\n    if (!this.canUndo()) {\n      return;\n    }\n\n    const { inversePatches } = this.timeline[this.pointer];\n    this.pointer = this.pointer - 1;\n    return applyPatches(state, inversePatches);\n  }\n\n  redo(state) {\n    if (!this.canRedo()) {\n      return;\n    }\n\n    this.pointer = this.pointer + 1;\n    const { patches } = this.timeline[this.pointer];\n    return applyPatches(state, patches);\n  }\n}\n","// https://github.com/pelotom/use-methods\nimport produce, {\n  Patch,\n  produceWithPatches,\n  enableMapSet,\n  enablePatches,\n} from 'immer';\nimport isEqualWith from 'lodash/isEqualWith';\nimport { useMemo, useEffect, useRef, useCallback } from 'react';\n\nimport { History, HISTORY_ACTIONS } from './History';\nimport { Delete } from './utilityTypes';\n\nenableMapSet();\nenablePatches();\n\nexport type SubscriberAndCallbacksFor<\n  M extends MethodsOrOptions,\n  Q extends QueryMethods = any\n> = {\n  subscribe: Watcher<StateFor<M>>['subscribe'];\n  getState: () => { prev: StateFor<M>; current: StateFor<M> };\n  actions: CallbacksFor<M>;\n  query: QueryCallbacksFor<Q>;\n  history: History;\n};\n\nexport type StateFor<M extends MethodsOrOptions> = M extends MethodsOrOptions<\n  infer S,\n  any\n>\n  ? S\n  : never;\n\nexport type CallbacksFor<\n  M extends MethodsOrOptions\n> = M extends MethodsOrOptions<any, infer R>\n  ? {\n      [T in ActionUnion<R>['type']]: (\n        ...payload: ActionByType<ActionUnion<R>, T>['payload']\n      ) => void;\n    } & {\n      history: {\n        undo: () => void;\n        redo: () => void;\n        clear: () => void;\n        throttle: (\n          rate?: number\n        ) => Delete<\n          {\n            [T in ActionUnion<R>['type']]: (\n              ...payload: ActionByType<ActionUnion<R>, T>['payload']\n            ) => void;\n          },\n          M extends Options ? M['ignoreHistoryForActions'][number] : never\n        >;\n        merge: () => Delete<\n          {\n            [T in ActionUnion<R>['type']]: (\n              ...payload: ActionByType<ActionUnion<R>, T>['payload']\n            ) => void;\n          },\n          M extends Options ? M['ignoreHistoryForActions'][number] : never\n        >;\n        ignore: () => Delete<\n          {\n            [T in ActionUnion<R>['type']]: (\n              ...payload: ActionByType<ActionUnion<R>, T>['payload']\n            ) => void;\n          },\n          M extends Options ? M['ignoreHistoryForActions'][number] : never\n        >;\n      };\n    }\n  : {};\n\nexport type Methods<S = any, R extends MethodRecordBase<S> = any, Q = any> = (\n  state: S,\n  query: Q\n) => R;\n\nexport type Options<S = any, R extends MethodRecordBase<S> = any, Q = any> = {\n  methods: Methods<S, R, Q>;\n  ignoreHistoryForActions: ReadonlyArray<keyof MethodRecordBase>;\n  normalizeHistory?: (state: S) => void;\n};\n\nexport type MethodsOrOptions<\n  S = any,\n  R extends MethodRecordBase<S> = any,\n  Q = any\n> = Methods<S, R, Q> | Options<S, R, Q>;\n\nexport type MethodRecordBase<S = any> = Record<\n  string,\n  (...args: any[]) => S extends object ? S | void : S\n>;\n\nexport type Action<T = any, P = any> = {\n  type: T;\n  payload?: P;\n  config?: Record<string, any>;\n};\n\nexport type ActionUnion<R extends MethodRecordBase> = {\n  [T in keyof R]: { type: T; payload: Parameters<R[T]> };\n}[keyof R];\n\nexport type ActionByType<A, T> = A extends { type: infer T2 }\n  ? T extends T2\n    ? A\n    : never\n  : never;\n\nexport type QueryMethods<\n  S = any,\n  O = any,\n  R extends MethodRecordBase<S> = any\n> = (state?: S, options?: O) => R;\nexport type QueryCallbacksFor<M extends QueryMethods> = M extends QueryMethods<\n  any,\n  any,\n  infer R\n>\n  ? {\n      [T in ActionUnion<R>['type']]: (\n        ...payload: ActionByType<ActionUnion<R>, T>['payload']\n      ) => ReturnType<R[T]>;\n    } & {\n      history: {\n        canUndo: () => boolean;\n        canRedo: () => boolean;\n      };\n    }\n  : {};\n\nexport type PatchListenerAction<M extends MethodsOrOptions> = {\n  type: keyof CallbacksFor<M>;\n  params: any;\n  patches: Patch[];\n};\n\nexport type PatchListener<\n  S,\n  M extends MethodsOrOptions,\n  Q extends QueryMethods\n> = (\n  newState: S,\n  previousState: S,\n  actionPerformedWithPatches: PatchListenerAction<M>,\n  query: QueryCallbacksFor<Q>,\n  normalizer: (cb: (draft: S) => void) => void\n) => void;\n\nexport function useMethods<S, R extends MethodRecordBase<S>>(\n  methodsOrOptions: MethodsOrOptions<S, R>, // methods to manipulate the state\n  initialState: any\n): SubscriberAndCallbacksFor<MethodsOrOptions<S, R>>;\n\nexport function useMethods<\n  S,\n  R extends MethodRecordBase<S>,\n  Q extends QueryMethods\n>(\n  methodsOrOptions: MethodsOrOptions<S, R, QueryCallbacksFor<Q>>, // methods to manipulate the state\n  initialState: any,\n  queryMethods: Q\n): SubscriberAndCallbacksFor<MethodsOrOptions<S, R>, Q>;\n\nexport function useMethods<\n  S,\n  R extends MethodRecordBase<S>,\n  Q extends QueryMethods\n>(\n  methodsOrOptions: MethodsOrOptions<S, R, QueryCallbacksFor<Q>>, // methods to manipulate the state\n  initialState: any,\n  queryMethods: Q,\n  patchListener: PatchListener<\n    S,\n    MethodsOrOptions<S, R, QueryCallbacksFor<Q>>,\n    Q\n  >\n): SubscriberAndCallbacksFor<MethodsOrOptions<S, R>, Q>;\n\nexport function useMethods<\n  S,\n  R extends MethodRecordBase<S>,\n  Q extends QueryMethods = null\n>(\n  methodsOrOptions: MethodsOrOptions<S, R>,\n  initialState: any,\n  queryMethods?: Q,\n  patchListener?: any\n): SubscriberAndCallbacksFor<MethodsOrOptions<S, R>, Q> {\n  const history = useMemo(() => new History(), []);\n\n  let methodsFactory: Methods<S, R>;\n  let ignoreHistoryForActionsRef = useRef([]);\n  let normalizeHistoryRef = useRef<any>(() => {});\n\n  if (typeof methodsOrOptions === 'function') {\n    methodsFactory = methodsOrOptions;\n  } else {\n    methodsFactory = methodsOrOptions.methods;\n    ignoreHistoryForActionsRef.current = methodsOrOptions.ignoreHistoryForActions as any;\n    normalizeHistoryRef.current = methodsOrOptions.normalizeHistory;\n  }\n\n  const patchListenerRef = useRef(patchListener);\n  patchListenerRef.current = patchListener;\n\n  const stateRef = useRef(initialState);\n\n  const reducer = useMemo(() => {\n    const { current: normalizeHistory } = normalizeHistoryRef;\n    const { current: ignoreHistoryForActions } = ignoreHistoryForActionsRef;\n    const { current: patchListener } = patchListenerRef;\n\n    return (state: S, action: Action) => {\n      const query =\n        queryMethods && createQuery(queryMethods, () => state, history);\n\n      let finalState;\n      let [nextState, patches, inversePatches] = (produceWithPatches as any)(\n        state,\n        (draft: S) => {\n          switch (action.type) {\n            case HISTORY_ACTIONS.UNDO: {\n              return history.undo(draft);\n            }\n            case HISTORY_ACTIONS.REDO: {\n              return history.redo(draft);\n            }\n            case HISTORY_ACTIONS.CLEAR: {\n              history.clear();\n              return {\n                ...draft,\n              };\n            }\n\n            // TODO: Simplify History API\n            case HISTORY_ACTIONS.IGNORE:\n            case HISTORY_ACTIONS.MERGE:\n            case HISTORY_ACTIONS.THROTTLE: {\n              const [type, ...params] = action.payload;\n              methodsFactory(draft, query)[type](...params);\n              break;\n            }\n            default:\n              methodsFactory(draft, query)[action.type](...action.payload);\n          }\n        }\n      );\n\n      finalState = nextState;\n\n      if (patchListener) {\n        patchListener(\n          nextState,\n          state,\n          { type: action.type, params: action.payload, patches },\n          query,\n          (cb) => {\n            let normalizedDraft = produceWithPatches(nextState, cb);\n            finalState = normalizedDraft[0];\n\n            patches = [...patches, ...normalizedDraft[1]];\n            inversePatches = [...normalizedDraft[2], ...inversePatches];\n          }\n        );\n      }\n\n      if (\n        [HISTORY_ACTIONS.UNDO, HISTORY_ACTIONS.REDO].includes(\n          action.type as any\n        ) &&\n        normalizeHistory\n      ) {\n        finalState = produce(finalState, normalizeHistory);\n      }\n\n      if (\n        ![\n          ...ignoreHistoryForActions,\n          HISTORY_ACTIONS.UNDO,\n          HISTORY_ACTIONS.REDO,\n          HISTORY_ACTIONS.IGNORE,\n          HISTORY_ACTIONS.CLEAR,\n        ].includes(action.type as any)\n      ) {\n        if (action.type === HISTORY_ACTIONS.THROTTLE) {\n          history.throttleAdd(\n            patches,\n            inversePatches,\n            action.config && action.config.rate\n          );\n        } else if (action.type === HISTORY_ACTIONS.MERGE) {\n          history.merge(patches, inversePatches);\n        } else {\n          history.add(patches, inversePatches);\n        }\n      }\n\n      return finalState;\n    };\n  }, [history, methodsFactory, queryMethods]);\n\n  const getState = useCallback(() => stateRef.current, []);\n  const watcher = useMemo(() => new Watcher<S>(getState), [getState]);\n\n  const dispatch = useCallback(\n    (action: any) => {\n      const newState = reducer(stateRef.current, action);\n      stateRef.current = newState;\n      watcher.notify();\n    },\n    [reducer, watcher]\n  );\n\n  useEffect(() => {\n    watcher.notify();\n  }, [watcher]);\n\n  const query = useMemo(\n    () =>\n      !queryMethods\n        ? []\n        : createQuery(queryMethods, () => stateRef.current, history),\n    [history, queryMethods]\n  );\n\n  const actions = useMemo(() => {\n    const actionTypes = Object.keys(methodsFactory(null, null));\n\n    const { current: ignoreHistoryForActions } = ignoreHistoryForActionsRef;\n\n    return {\n      ...actionTypes.reduce((accum, type) => {\n        accum[type] = (...payload) => dispatch({ type, payload });\n        return accum;\n      }, {} as any),\n      history: {\n        undo() {\n          return dispatch({\n            type: HISTORY_ACTIONS.UNDO,\n          });\n        },\n        redo() {\n          return dispatch({\n            type: HISTORY_ACTIONS.REDO,\n          });\n        },\n        clear: () => {\n          return dispatch({\n            type: HISTORY_ACTIONS.CLEAR,\n          });\n        },\n        throttle: (rate) => {\n          return {\n            ...actionTypes\n              .filter((type) => !ignoreHistoryForActions.includes(type))\n              .reduce((accum, type) => {\n                accum[type] = (...payload) =>\n                  dispatch({\n                    type: HISTORY_ACTIONS.THROTTLE,\n                    payload: [type, ...payload],\n                    config: {\n                      rate: rate,\n                    },\n                  });\n                return accum;\n              }, {} as any),\n          };\n        },\n        ignore: () => {\n          return {\n            ...actionTypes\n              .filter((type) => !ignoreHistoryForActions.includes(type))\n              .reduce((accum, type) => {\n                accum[type] = (...payload) =>\n                  dispatch({\n                    type: HISTORY_ACTIONS.IGNORE,\n                    payload: [type, ...payload],\n                  });\n                return accum;\n              }, {} as any),\n          };\n        },\n        merge: () => {\n          return {\n            ...actionTypes\n              .filter((type) => !ignoreHistoryForActions.includes(type))\n              .reduce((accum, type) => {\n                accum[type] = (...payload) =>\n                  dispatch({\n                    type: HISTORY_ACTIONS.MERGE,\n                    payload: [type, ...payload],\n                  });\n                return accum;\n              }, {} as any),\n          };\n        },\n      },\n    };\n  }, [dispatch, methodsFactory]);\n\n  return useMemo(\n    () => ({\n      getState,\n      subscribe: (collector, cb, collectOnCreate) =>\n        watcher.subscribe(collector, cb, collectOnCreate),\n      actions,\n      query,\n      history,\n    }),\n    [actions, query, watcher, getState, history]\n  ) as any;\n}\n\nexport function createQuery<Q extends QueryMethods>(\n  queryMethods: Q,\n  getState,\n  history: History\n) {\n  const queries = Object.keys(queryMethods()).reduce((accum, key) => {\n    return {\n      ...accum,\n      [key]: (...args: any) => {\n        return queryMethods(getState())[key](...args);\n      },\n    };\n  }, {} as QueryCallbacksFor<typeof queryMethods>);\n\n  return {\n    ...queries,\n    history: {\n      canUndo: () => history.canUndo(),\n      canRedo: () => history.canRedo(),\n    },\n  };\n}\n\nclass Watcher<S> {\n  getState;\n  subscribers: Subscriber[] = [];\n\n  constructor(getState) {\n    this.getState = getState;\n  }\n\n  /**\n   * Creates a Subscriber\n   * @returns {() => void} a Function that removes the Subscriber\n   */\n  subscribe<C>(\n    collector: (state: S) => C,\n    onChange: (collected: C) => void,\n    collectOnCreate?: boolean\n  ): () => void {\n    const subscriber = new Subscriber(\n      () => collector(this.getState()),\n      onChange,\n      collectOnCreate\n    );\n    this.subscribers.push(subscriber);\n    return this.unsubscribe.bind(this, subscriber);\n  }\n\n  unsubscribe(subscriber) {\n    if (this.subscribers.length) {\n      const index = this.subscribers.indexOf(subscriber);\n      if (index > -1) return this.subscribers.splice(index, 1);\n    }\n  }\n\n  notify() {\n    this.subscribers.forEach((subscriber) => subscriber.collect());\n  }\n}\n\nclass Subscriber {\n  collected: any;\n  collector: () => any;\n  onChange: (collected: any) => void;\n  id;\n\n  /**\n   * Creates a Subscriber\n   * @param collector The method that returns an object of values to be collected\n   * @param onChange A callback method that is triggered when the collected values has changed\n   * @param collectOnCreate If set to true, the collector/onChange will be called on instantiation\n   */\n  constructor(collector, onChange, collectOnCreate = false) {\n    this.collector = collector;\n    this.onChange = onChange;\n\n    // Collect and run onChange callback when Subscriber is created\n    if (collectOnCreate) this.collect();\n  }\n\n  collect() {\n    try {\n      const recollect = this.collector();\n      if (!isEqualWith(recollect, this.collected)) {\n        this.collected = recollect;\n        if (this.onChange) this.onChange(this.collected);\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.warn(err);\n    }\n  }\n}\n","import { nanoid } from 'nanoid';\n\n// By default nanoid generate an ID with 21 characters. To reduce the footprint, we default to 10 characters.\n// We have a higher probability for collisions, though\n\n/**\n * Generate a random ID. That ID can for example be used as a node ID.\n *\n * @param size The number of characters that are generated for the ID. Defaults to `10`\n * @returns A random id\n */\nexport const getRandomId = (size: number = 10) => nanoid(size);\n","import isEqual from 'shallowequal';\n\nimport { ConnectorToRegister, RegisteredConnector } from './interfaces';\n\nimport { getRandomId } from '../getRandomId';\n\n/**\n * Stores all connected DOM elements and their connectors here\n * This allows us to easily enable/disable and perform cleanups\n */\nexport class ConnectorRegistry {\n  private isEnabled: boolean = true;\n\n  private elementIdMap: WeakMap<HTMLElement, string> = new WeakMap();\n  private registry: Map<String, RegisteredConnector> = new Map();\n\n  private getElementId(element: HTMLElement) {\n    const existingId = this.elementIdMap.get(element);\n    if (existingId) {\n      return existingId;\n    }\n\n    const newId = getRandomId();\n\n    this.elementIdMap.set(element, newId);\n    return newId;\n  }\n\n  getConnectorId(element: HTMLElement, connectorName: string) {\n    const elementId = this.getElementId(element);\n    return `${connectorName}--${elementId}`;\n  }\n\n  register(element: HTMLElement, connectorPayload: ConnectorToRegister) {\n    const existingConnector = this.getByElement(element, connectorPayload.name);\n\n    if (existingConnector) {\n      if (isEqual(connectorPayload.required, existingConnector.required)) {\n        return existingConnector;\n      }\n\n      this.getByElement(element, connectorPayload.name).disable();\n    }\n\n    let cleanup: () => void | null = null;\n\n    const id = this.getConnectorId(element, connectorPayload.name);\n    this.registry.set(id, {\n      id,\n      required: connectorPayload.required,\n      enable: () => {\n        if (cleanup) {\n          cleanup();\n        }\n\n        cleanup = connectorPayload.connector(\n          element,\n          connectorPayload.required,\n          connectorPayload.options\n        );\n      },\n      disable: () => {\n        if (!cleanup) {\n          return;\n        }\n\n        cleanup();\n      },\n      remove: () => {\n        return this.remove(id);\n      },\n    });\n\n    if (this.isEnabled) {\n      this.registry.get(id).enable();\n    }\n\n    return this.registry.get(id);\n  }\n\n  get(id: string) {\n    return this.registry.get(id);\n  }\n\n  remove(id: string) {\n    const connector = this.get(id);\n    if (!connector) {\n      return;\n    }\n\n    connector.disable();\n    this.registry.delete(connector.id);\n  }\n\n  enable() {\n    this.isEnabled = true;\n    this.registry.forEach((connectors) => {\n      connectors.enable();\n    });\n  }\n\n  disable() {\n    this.isEnabled = false;\n    this.registry.forEach((connectors) => {\n      connectors.disable();\n    });\n  }\n\n  getByElement(element: HTMLElement, connectorName: string) {\n    return this.get(this.getConnectorId(element, connectorName));\n  }\n\n  removeByElement(element: HTMLElement, connectorName: string) {\n    return this.remove(this.getConnectorId(element, connectorName));\n  }\n\n  clear() {\n    this.disable();\n    this.elementIdMap = new WeakMap();\n    this.registry = new Map();\n  }\n}\n","import { EventHandlers } from './EventHandlers';\n\nexport type Connector = (el: HTMLElement, ...args: any) => any;\n\nexport type ConnectorsRecord = Record<string, Connector>;\n\nexport type ChainableConnector<T extends Connector, O extends any> = T extends (\n  element: infer E,\n  ...args: infer P\n) => any\n  ? <B extends E | O>(element: B, ...args: P) => B\n  : never;\n\nexport type ChainableConnectors<\n  H extends ConnectorsRecord,\n  E extends any = HTMLElement\n> = {\n  [T in keyof H]: H[T] extends Connector ? ChainableConnector<H[T], E> : never;\n};\n\nexport type CraftDOMEvent<T extends Event> = T & {\n  craft: {\n    stopPropagation: () => void;\n    blockedEvents: Record<string, HTMLElement[]>;\n  };\n};\n\nexport type CraftEventListener<K extends keyof HTMLElementEventMap> = (\n  ev: CraftDOMEvent<HTMLElementEventMap[K]>\n) => any;\n\nexport type EventHandlerConnectors<\n  H extends EventHandlers,\n  E extends any = HTMLElement\n> = ChainableConnectors<ReturnType<H['handlers']>, E>;\n\nexport type ConnectorsUsage<H extends EventHandlers> = {\n  register: () => void;\n  cleanup: () => void;\n  connectors: EventHandlerConnectors<H>;\n};\n\nexport enum EventHandlerUpdates {\n  HandlerDisabled,\n  HandlerEnabled,\n}\n\nexport type ConnectorToRegister = {\n  name: string;\n  required: any;\n  connector: Connector;\n  options?: Record<string, any>;\n};\n\nexport type RegisteredConnector = {\n  id: string;\n  required: any;\n  enable: () => void;\n  disable: () => void;\n  remove: () => void;\n};\n","import { ConnectorRegistry } from './ConnectorRegistry';\nimport {\n  EventHandlerUpdates,\n  CraftEventListener,\n  EventHandlerConnectors,\n  CraftDOMEvent,\n  Connector,\n  ConnectorsUsage,\n  RegisteredConnector,\n} from './interfaces';\nimport { isEventBlockedByDescendant } from './isEventBlockedByDescendant';\n\nexport abstract class EventHandlers<O extends Record<string, any> = {}> {\n  options: O;\n\n  private registry: ConnectorRegistry = new ConnectorRegistry();\n  private subscribers: Set<(msg: EventHandlerUpdates) => void> = new Set();\n\n  onEnable?(): void;\n  onDisable?(): void;\n\n  constructor(options?: O) {\n    this.options = options;\n  }\n\n  listen(cb: (msg: EventHandlerUpdates) => void) {\n    this.subscribers.add(cb);\n    return () => this.subscribers.delete(cb);\n  }\n\n  disable() {\n    if (this.onDisable) {\n      this.onDisable();\n    }\n\n    this.registry.disable();\n\n    this.subscribers.forEach((listener) => {\n      listener(EventHandlerUpdates.HandlerDisabled);\n    });\n  }\n\n  enable() {\n    if (this.onEnable) {\n      this.onEnable();\n    }\n\n    this.registry.enable();\n\n    this.subscribers.forEach((listener) => {\n      listener(EventHandlerUpdates.HandlerEnabled);\n    });\n  }\n\n  cleanup() {\n    this.disable();\n    this.subscribers.clear();\n    this.registry.clear();\n  }\n\n  addCraftEventListener<K extends keyof HTMLElementEventMap>(\n    el: HTMLElement,\n    eventName: K,\n    listener: CraftEventListener<K>,\n    options?: boolean | AddEventListenerOptions\n  ) {\n    const bindedListener = (e: CraftDOMEvent<HTMLElementEventMap[K]>) => {\n      if (!isEventBlockedByDescendant(e, eventName, el)) {\n        e.craft.stopPropagation = () => {\n          if (!e.craft.blockedEvents[eventName]) {\n            e.craft.blockedEvents[eventName] = [];\n          }\n\n          e.craft.blockedEvents[eventName].push(el);\n        };\n\n        listener(e);\n      }\n    };\n\n    el.addEventListener(eventName, bindedListener, options);\n\n    return () => el.removeEventListener(eventName, bindedListener, options);\n  }\n\n  // Defines the connectors and their logic\n  abstract handlers(): Record<string, (el: HTMLElement, ...args: any[]) => any>;\n\n  /**\n   * Creates a record of chainable connectors and tracks their usages\n   */\n  createConnectorsUsage(): ConnectorsUsage<this> {\n    const handlers = this.handlers();\n\n    // Track all active connector ids here\n    // This is so we can return a cleanup method below so the callee can programmatically cleanup all connectors\n\n    const activeConnectorIds: Set<string> = new Set();\n\n    let canRegisterConnectors = false;\n    const connectorsToRegister: Map<\n      string,\n      () => RegisteredConnector\n    > = new Map();\n\n    const connectors = Object.entries(handlers).reduce<\n      Record<string, Connector>\n    >(\n      (accum, [name, handler]) => ({\n        ...accum,\n        [name]: (el, required, options) => {\n          const registerConnector = () => {\n            const connector = this.registry.register(el, {\n              required,\n              name,\n              options,\n              connector: handler,\n            });\n\n            activeConnectorIds.add(connector.id);\n            return connector;\n          };\n\n          connectorsToRegister.set(\n            this.registry.getConnectorId(el, name),\n            registerConnector\n          );\n\n          /**\n           * If register() has been called,\n           * register the connector immediately.\n           *\n           * Otherwise, registration is deferred until after register() is called\n           */\n          if (canRegisterConnectors) {\n            registerConnector();\n          }\n\n          return el;\n        },\n      }),\n      {}\n    ) as any;\n\n    return {\n      connectors,\n      register: () => {\n        canRegisterConnectors = true;\n\n        connectorsToRegister.forEach((registerConnector) => {\n          registerConnector();\n        });\n      },\n      cleanup: () => {\n        canRegisterConnectors = false;\n\n        activeConnectorIds.forEach((connectorId) =>\n          this.registry.remove(connectorId)\n        );\n      },\n    };\n  }\n\n  derive<C extends EventHandlers>(\n    type: {\n      new (...args: any[]): C;\n    },\n    opts: C['options']\n  ) {\n    return new type(this, opts);\n  }\n\n  // This method allows us to execute multiple connectors and returns a single cleanup method for all of them\n  protected createProxyHandlers<H extends EventHandlers>(\n    instance: H,\n    cb: (connectors: EventHandlerConnectors<H>) => void\n  ) {\n    const connectorsToCleanup = [];\n    const handlers = instance.handlers();\n\n    const proxiedHandlers = new Proxy(handlers, {\n      get: (target, key: any, receiver) => {\n        if (key in handlers === false) {\n          return Reflect.get(target, key, receiver);\n        }\n\n        return (el, ...args) => {\n          const cleanup = handlers[key](el, ...args);\n          if (!cleanup) {\n            return;\n          }\n\n          connectorsToCleanup.push(cleanup);\n        };\n      },\n    });\n\n    cb(proxiedHandlers as any);\n\n    return () => {\n      connectorsToCleanup.forEach((cleanup) => {\n        cleanup();\n      });\n    };\n  }\n\n  // This lets us to execute and cleanup sibling connectors\n  reflect(cb: (connectors: EventHandlerConnectors<this>) => void) {\n    return this.createProxyHandlers(this, cb);\n  }\n}\n","import { CraftDOMEvent } from './interfaces';\n\n/**\n * Check if a specified event is blocked by a child\n * that's a descendant of the specified element\n */\nexport function isEventBlockedByDescendant<K extends keyof HTMLElementEventMap>(\n  e: CraftDOMEvent<HTMLElementEventMap[K]>,\n  eventName: K,\n  el: HTMLElement\n) {\n  // Store initial Craft event value\n  if (!e.craft) {\n    e.craft = {\n      stopPropagation: () => {},\n      blockedEvents: {},\n    };\n  }\n\n  const blockingElements = (e.craft && e.craft.blockedEvents[eventName]) || [];\n\n  for (let i = 0; i < blockingElements.length; i++) {\n    const blockingElement = blockingElements[i];\n\n    if (el !== blockingElement && el.contains(blockingElement)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","// https://github.com/react-dnd/react-dnd\nimport { isValidElement, ReactElement } from 'react';\nimport { cloneElement } from 'react';\nimport invariant from 'tiny-invariant';\n\nimport { ChainableConnectors, ConnectorsRecord } from './interfaces';\n\nfunction setRef(ref: any, node: any) {\n  if (node) {\n    if (typeof ref === 'function') {\n      ref(node);\n    } else {\n      ref.current = node;\n    }\n  }\n}\n\nexport function cloneWithRef(\n  element: any,\n  newRef: any\n): React.ReactElement<any> {\n  const previousRef = element.ref;\n  invariant(\n    typeof previousRef !== 'string',\n    'Cannot connect to an element with an existing string ref. ' +\n      'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' +\n      'Read more: https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute'\n  );\n\n  if (!previousRef) {\n    // When there is no ref on the element, use the new ref directly\n    return cloneElement(element, {\n      ref: newRef,\n    });\n  } else {\n    return cloneElement(element, {\n      ref: (node: any) => {\n        setRef(previousRef, node);\n        setRef(newRef, node);\n      },\n    });\n  }\n}\n\nfunction throwIfCompositeComponentElement(element: React.ReactElement<any>) {\n  if (typeof element.type === 'string') {\n    return;\n  }\n\n  throw new Error();\n}\n\nexport function wrapHookToRecognizeElement(\n  hook: (node: any, ...args: any[]) => void\n) {\n  return (elementOrNode = null, ...args: any) => {\n    // When passed a node, call the hook straight away.\n    if (!isValidElement(elementOrNode)) {\n      if (!elementOrNode) {\n        return;\n      }\n\n      const node = elementOrNode;\n      node && hook(node, ...args);\n      return node;\n    }\n\n    // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n    const element: ReactElement | null = elementOrNode;\n    throwIfCompositeComponentElement(element as any);\n\n    return cloneWithRef(element, hook);\n  };\n}\n\n// A React wrapper for our connectors\n// Wrap all our connectors so that would additionally accept React.ReactElement\nexport function wrapConnectorHooks<H extends ConnectorsRecord>(\n  connectors: H\n): ChainableConnectors<H, React.ReactElement | HTMLElement> {\n  return Object.keys(connectors).reduce((accum, key) => {\n    accum[key] = wrapHookToRecognizeElement((...args) => {\n      // @ts-ignore\n      return connectors[key](...args);\n    });\n\n    return accum;\n  }, {}) as any;\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\ntype RenderIndicatorProps = {\n  style: React.CSSProperties;\n  className?: string;\n  parentDom?: HTMLElement;\n};\n\nexport const RenderIndicator = ({\n  style,\n  className,\n  parentDom,\n}: RenderIndicatorProps) => {\n  const indicator = (\n    <div\n      className={className}\n      style={{\n        position: 'fixed',\n        display: 'block',\n        opacity: 1,\n        borderStyle: 'solid',\n        borderWidth: '1px',\n        borderColor: 'transparent',\n        zIndex: 99999,\n        ...style,\n      }}\n    ></div>\n  );\n\n  if (parentDom && parentDom.ownerDocument !== document) {\n    return ReactDOM.createPortal(indicator, parentDom.ownerDocument.body);\n  }\n\n  return indicator;\n};\n","export const isClientSide = () => typeof window !== 'undefined';\n\nexport const isLinux = () =>\n  isClientSide() && /Linux/i.test(window.navigator.userAgent);\n\nexport const isChromium = () =>\n  isClientSide() && /Chrome/i.test(window.navigator.userAgent);\n","export const ROOT_NODE = 'ROOT';\nexport const DEPRECATED_ROOT_NODE = 'canvas-ROOT';\n\n// TODO: Use a better way to store/display error messages\nexport const ERROR_NOPARENT = 'Parent id cannot be ommited';\nexport const ERROR_DUPLICATE_NODEID =\n  'Attempting to add a node with duplicated id';\nexport const ERROR_INVALID_NODEID =\n  'Node does not exist, it may have been removed';\nexport const ERROR_TOP_LEVEL_ELEMENT_NO_ID =\n  'A <Element /> that is used inside a User Component must specify an `id` prop, eg: <Element id=\"text_element\">...</Element> ';\nexport const ERROR_MISSING_PLACEHOLDER_PLACEMENT =\n  'Placeholder required placement info (parent, index, or where) is missing';\nexport const ERROR_MOVE_CANNOT_DROP =\n  'Node cannot be dropped into target parent';\nexport const ERROR_MOVE_INCOMING_PARENT = 'Target parent rejects incoming node';\nexport const ERROR_MOVE_OUTGOING_PARENT =\n  'Current parent rejects outgoing node';\nexport const ERROR_MOVE_NONCANVAS_CHILD =\n  'Cannot move node that is not a direct child of a Canvas node';\nexport const ERROR_MOVE_TO_NONCANVAS_PARENT =\n  'Cannot move node into a non-Canvas parent';\nexport const ERROR_MOVE_TOP_LEVEL_NODE = 'A top-level Node cannot be moved';\nexport const ERROR_MOVE_ROOT_NODE = 'Root Node cannot be moved';\n\nexport const ERROR_MOVE_TO_DESCENDANT = 'Cannot move node into a descendant';\nexport const ERROR_NOT_IN_RESOLVER =\n  'The component type specified for this node (%node_type%) does not exist in the resolver';\nexport const ERROR_INFINITE_CANVAS =\n  \"The component specified in the <Canvas> `is` prop has additional Canvas specified in it's render template.\";\nexport const ERROR_CANNOT_DRAG =\n  'The node has specified a canDrag() rule that prevents it from being dragged';\nexport const ERROR_INVALID_NODE_ID = 'Invalid parameter Node Id specified';\nexport const ERROR_DELETE_TOP_LEVEL_NODE =\n  'Attempting to delete a top-level Node';\n\nexport const ERROR_RESOLVER_NOT_AN_OBJECT = `Resolver in <Editor /> has to be an object. For (de)serialization Craft.js needs a list of all the User Components. \n    \nMore info: https://craft.js.org/r/docs/api/editor#props`;\n\nexport const ERROR_DESERIALIZE_COMPONENT_NOT_IN_RESOLVER = `An Error occurred while deserializing components: Cannot find component <%displayName% /> in resolver map. Please check your resolver in <Editor />\n\nAvailable components in resolver: %availableComponents%\n\nMore info: https://craft.js.org/r/docs/api/editor#props`;\n\nexport const ERROR_USE_EDITOR_OUTSIDE_OF_EDITOR_CONTEXT = `You can only use useEditor in the context of <Editor />. \n\nPlease only use useEditor in components that are children of the <Editor /> component.`;\n\nexport const ERROR_USE_NODE_OUTSIDE_OF_EDITOR_CONTEXT = `You can only use useNode in the context of <Editor />. \n\nPlease only use useNode in components that are children of the <Editor /> component.`;\n","import { EventHandlers } from './EventHandlers';\nimport { EventHandlerConnectors, EventHandlerUpdates } from './interfaces';\n\n// Creates EventHandlers that depends on another EventHandlers instance\n// This lets us to easily create new connectors that composites of the parent EventHandlers instance\nexport abstract class DerivedEventHandlers<\n  P extends EventHandlers,\n  O extends Record<string, any> = {}\n> extends EventHandlers<O> {\n  derived: P;\n  unsubscribeParentHandlerListener: () => void;\n\n  constructor(derived: P, options?: O) {\n    super(options);\n    this.derived = derived;\n    this.options = options;\n\n    // Automatically disable/enable depending on the parent handlers\n    this.unsubscribeParentHandlerListener = this.derived.listen((msg) => {\n      switch (msg) {\n        case EventHandlerUpdates.HandlerEnabled: {\n          return this.enable();\n        }\n        case EventHandlerUpdates.HandlerDisabled: {\n          return this.disable();\n        }\n        default: {\n          return;\n        }\n      }\n    });\n  }\n\n  // A method to easily inherit parent connectors\n  inherit(cb: (connectors: EventHandlerConnectors<P>) => void) {\n    return this.createProxyHandlers(this.derived, cb);\n  }\n\n  cleanup() {\n    super.cleanup();\n    this.unsubscribeParentHandlerListener();\n  }\n}\n","type DeprecationPayload = Partial<{\n  suggest: string;\n  doc: string;\n}>;\n\nexport const deprecationWarning = (name, payload?: DeprecationPayload) => {\n  let message = `Deprecation warning: ${name} will be deprecated in future relases.`;\n\n  const { suggest, doc } = payload;\n\n  if (suggest) {\n    message += ` Please use ${suggest} instead.`;\n  }\n\n  // URL link to Documentation\n  if (doc) {\n    message += `(${doc})`;\n  }\n\n  // eslint-disable-next-line no-console\n  console.warn(message);\n};\n","export const getDOMInfo = (el: HTMLElement) => {\n  const {\n    x,\n    y,\n    top,\n    left,\n    bottom,\n    right,\n    width,\n    height,\n  } = el.getBoundingClientRect() as DOMRect;\n\n  const style = window.getComputedStyle(el);\n\n  const margin = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight),\n    bottom: parseInt(style.marginBottom),\n    top: parseInt(style.marginTop),\n  };\n\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight),\n    bottom: parseInt(style.paddingBottom),\n    top: parseInt(style.paddingTop),\n  };\n\n  const styleInFlow = (parent: HTMLElement) => {\n    const parentStyle: any = getComputedStyle(parent);\n\n    if (style.overflow && style.overflow !== 'visible') {\n      return;\n    }\n\n    if (parentStyle.float !== 'none') {\n      return;\n    }\n\n    if (parentStyle.display === 'grid') {\n      return;\n    }\n\n    if (\n      parentStyle.display === 'flex' &&\n      parentStyle['flex-direction'] !== 'column'\n    ) {\n      return;\n    }\n\n    switch (style.position) {\n      case 'static':\n      case 'relative':\n        break;\n      default:\n        return;\n    }\n\n    switch (el.tagName) {\n      case 'TR':\n      case 'TBODY':\n      case 'THEAD':\n      case 'TFOOT':\n        return true;\n    }\n\n    switch (style.display) {\n      case 'block':\n      case 'list-item':\n      case 'table':\n      case 'flex':\n      case 'grid':\n        return true;\n    }\n\n    return;\n  };\n\n  return {\n    x,\n    y,\n    top,\n    left,\n    bottom,\n    right,\n    width,\n    height,\n    outerWidth: Math.round(width + margin.left + margin.right),\n    outerHeight: Math.round(height + margin.top + margin.bottom),\n    margin,\n    padding,\n    inFlow: el.parentElement && !!styleInFlow(el.parentElement),\n  };\n};\n","import { useState, useCallback, useRef, useEffect } from 'react';\n\nimport { SubscriberAndCallbacksFor } from './useMethods';\nimport { ConditionallyMergeRecordTypes } from './utilityTypes';\n\ntype CollectorMethods<S extends SubscriberAndCallbacksFor<any, any>> = {\n  actions: S['actions'];\n  query: S['query'];\n};\n\nexport type useCollectorReturnType<\n  S extends SubscriberAndCallbacksFor<any, any>,\n  C = null\n> = ConditionallyMergeRecordTypes<C, CollectorMethods<S>>;\nexport function useCollector<S extends SubscriberAndCallbacksFor<any, any>, C>(\n  store: S,\n  collector?: (\n    state: ReturnType<S['getState']>['current'],\n    query: S['query']\n  ) => C\n): useCollectorReturnType<S, C> {\n  const { subscribe, getState, actions, query } = store;\n\n  const initial = useRef(true);\n  const collected = useRef<any>(null);\n  const collectorRef = useRef(collector);\n  collectorRef.current = collector;\n\n  const onCollect = useCallback(\n    (collected) => {\n      return { ...collected, actions, query };\n    },\n    [actions, query]\n  );\n\n  // Collect states for initial render\n  if (initial.current && collector) {\n    collected.current = collector(getState(), query);\n    initial.current = false;\n  }\n\n  const [renderCollected, setRenderCollected] = useState(\n    onCollect(collected.current)\n  );\n\n  // Collect states on state change\n  useEffect(() => {\n    let unsubscribe;\n    if (collectorRef.current) {\n      unsubscribe = subscribe(\n        (current) => collectorRef.current(current, query),\n        (collected) => {\n          setRenderCollected(onCollect(collected));\n        }\n      );\n    }\n    return () => {\n      if (unsubscribe) unsubscribe();\n    };\n  }, [onCollect, query, subscribe]);\n\n  return renderCollected;\n}\n","import { useEffect } from 'react';\n\nexport const useEffectOnce = (effect: () => void) => {\n  /* eslint-disable-next-line react-hooks/exhaustive-deps */\n  useEffect(effect, []);\n};\n"],"names":["HISTORY_ACTIONS","UNDO","REDO","THROTTLE","IGNORE","MERGE","CLEAR","History","constructor","_defineProperty","this","add","patches","inversePatches","length","pointer","timeline","timestamp","Date","now","throttleAdd","throttleRate","currPatches","currInversePatches","getTime","merge","clear","canUndo","canRedo","undo","state","applyPatches","redo","createQuery","queryMethods","getState","history","queries","Object","keys","reduce","accum","key","_objectSpread","arguments","enableMapSet","enablePatches","Watcher","subscribe","collector","onChange","collectOnCreate","subscriber","Subscriber","subscribers","push","unsubscribe","bind","index","indexOf","splice","notify","forEach","collect","undefined","recollect","isEqualWith","collected","err","console","warn","getRandomId","nanoid","ConnectorRegistry","WeakMap","Map","getElementId","element","existingId","elementIdMap","get","newId","set","getConnectorId","connectorName","elementId","concat","register","connectorPayload","existingConnector","getByElement","name","isEqual","required","disable","cleanup","id","registry","enable","connector","options","remove","isEnabled","delete","connectors","removeByElement","EventHandlerUpdates","EventHandlers","Set","listen","cb","onDisable","listener","HandlerDisabled","onEnable","HandlerEnabled","addCraftEventListener","el","eventName","bindedListener","e","craft","stopPropagation","blockedEvents","blockingElements","i","blockingElement","contains","isEventBlockedByDescendant","addEventListener","removeEventListener","createConnectorsUsage","handlers","activeConnectorIds","canRegisterConnectors","connectorsToRegister","entries","_ref","handler","registerConnector","connectorId","derive","type","opts","createProxyHandlers","instance","connectorsToCleanup","proxiedHandlers","Proxy","target","receiver","Reflect","_len","args","Array","_key","reflect","setRef","ref","node","current","cloneWithRef","newRef","previousRef","invariant","cloneElement","wrapHookToRecognizeElement","hook","elementOrNode","isValidElement","Error","throwIfCompositeComponentElement","isClientSide","window","derived","super","unsubscribeParentHandlerListener","msg","inherit","style","className","parentDom","indicator","React","createElement","position","display","opacity","borderStyle","borderWidth","borderColor","zIndex","ownerDocument","document","ReactDOM","createPortal","body","deprecationWarning","payload","message","suggest","doc","x","y","top","left","bottom","right","width","height","getBoundingClientRect","getComputedStyle","margin","parseInt","marginLeft","marginRight","marginBottom","marginTop","padding","paddingLeft","paddingRight","paddingBottom","paddingTop","outerWidth","Math","round","outerHeight","inFlow","parentElement","parent","parentStyle","overflow","float","tagName","styleInFlow","isChromium","test","navigator","userAgent","isLinux","store","actions","query","initial","useRef","collectorRef","onCollect","useCallback","renderCollected","setRenderCollected","useState","useEffect","effect","methodsOrOptions","initialState","patchListener","useMemo","methodsFactory","ignoreHistoryForActionsRef","normalizeHistoryRef","methods","ignoreHistoryForActions","normalizeHistory","patchListenerRef","stateRef","reducer","action","finalState","nextState","produceWithPatches","draft","params","normalizedDraft","includes","produce","config","rate","watcher","dispatch","newState","actionTypes","throttle","filter","_len2","_key2","ignore","_len3","_key3","_len4","_key4"],"mappings":"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"}