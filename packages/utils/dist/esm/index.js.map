{"version":3,"file":"index.js","sources":["../../src/constants.ts","../../src/History.ts","../../src/useMethods.ts","../../src/getDOMInfo.ts","../../src/useCollector.tsx","../../src/getRandomId.ts","../../src/EventHandlers/ConnectorRegistry.ts","../../src/EventHandlers/interfaces.ts","../../src/EventHandlers/EventHandlers.ts","../../src/EventHandlers/isEventBlockedByDescendant.ts","../../src/EventHandlers/DerivedEventHandlers.ts","../../src/EventHandlers/wrapConnectorHooks.tsx","../../src/RenderIndicator.tsx","../../src/useEffectOnce.tsx","../../src/deprecate.ts","../../src/platform.ts"],"sourcesContent":["export const ROOT_NODE = 'ROOT';\nexport const DEPRECATED_ROOT_NODE = 'canvas-ROOT';\n\n// TODO: Use a better way to store/display error messages\nexport const ERROR_NOPARENT = 'Parent id cannot be ommited';\nexport const ERROR_DUPLICATE_NODEID =\n  'Attempting to add a node with duplicated id';\nexport const ERROR_INVALID_NODEID =\n  'Node does not exist, it may have been removed';\nexport const ERROR_TOP_LEVEL_ELEMENT_NO_ID =\n  'A <Element /> that is used inside a User Component must specify an `id` prop, eg: <Element id=\"text_element\">...</Element> ';\nexport const ERROR_MISSING_PLACEHOLDER_PLACEMENT =\n  'Placeholder required placement info (parent, index, or where) is missing';\nexport const ERROR_MOVE_CANNOT_DROP =\n  'Node cannot be dropped into target parent';\nexport const ERROR_MOVE_INCOMING_PARENT = 'Target parent rejects incoming node';\nexport const ERROR_MOVE_OUTGOING_PARENT =\n  'Current parent rejects outgoing node';\nexport const ERROR_MOVE_NONCANVAS_CHILD =\n  'Cannot move node that is not a direct child of a Canvas node';\nexport const ERROR_MOVE_TO_NONCANVAS_PARENT =\n  'Cannot move node into a non-Canvas parent';\nexport const ERROR_MOVE_TOP_LEVEL_NODE = 'A top-level Node cannot be moved';\nexport const ERROR_MOVE_ROOT_NODE = 'Root Node cannot be moved';\n\nexport const ERROR_MOVE_TO_DESCENDANT = 'Cannot move node into a descendant';\nexport const ERROR_NOT_IN_RESOLVER =\n  'The component type specified for this node (%node_type%) does not exist in the resolver';\nexport const ERROR_INFINITE_CANVAS =\n  \"The component specified in the <Canvas> `is` prop has additional Canvas specified in it's render template.\";\nexport const ERROR_CANNOT_DRAG =\n  'The node has specified a canDrag() rule that prevents it from being dragged';\nexport const ERROR_INVALID_NODE_ID = 'Invalid parameter Node Id specified';\nexport const ERROR_DELETE_TOP_LEVEL_NODE =\n  'Attempting to delete a top-level Node';\n\nexport const ERROR_RESOLVER_NOT_AN_OBJECT = `Resolver in <Editor /> has to be an object. For (de)serialization Craft.js needs a list of all the User Components. \n    \nMore info: https://craft.js.org/r/docs/api/editor#props`;\n\nexport const ERROR_DESERIALIZE_COMPONENT_NOT_IN_RESOLVER = `An Error occurred while deserializing components: Cannot find component <%displayName% /> in resolver map. Please check your resolver in <Editor />\n\nAvailable components in resolver: %availableComponents%\n\nMore info: https://craft.js.org/r/docs/api/editor#props`;\n\nexport const ERROR_USE_EDITOR_OUTSIDE_OF_EDITOR_CONTEXT = `You can only use useEditor in the context of <Editor />. \n\nPlease only use useEditor in components that are children of the <Editor /> component.`;\n\nexport const ERROR_USE_NODE_OUTSIDE_OF_EDITOR_CONTEXT = `You can only use useNode in the context of <Editor />. \n\nPlease only use useNode in components that are children of the <Editor /> component.`;\n","import { Patch, applyPatches } from 'immer';\n\ntype Timeline = Array<{\n  patches: Patch[];\n  inversePatches: Patch[];\n  timestamp: number;\n}>;\n\nexport const HISTORY_ACTIONS = {\n  UNDO: 'HISTORY_UNDO',\n  REDO: 'HISTORY_REDO',\n  THROTTLE: 'HISTORY_THROTTLE',\n  IGNORE: 'HISTORY_IGNORE',\n  MERGE: 'HISTORY_MERGE',\n  CLEAR: 'HISTORY_CLEAR',\n};\n\nexport class History {\n  timeline: Timeline = [];\n  pointer = -1;\n\n  add(patches: Patch[], inversePatches: Patch[]) {\n    if (patches.length === 0 && inversePatches.length === 0) {\n      return;\n    }\n\n    this.pointer = this.pointer + 1;\n    this.timeline.length = this.pointer;\n    this.timeline[this.pointer] = {\n      patches,\n      inversePatches,\n      timestamp: Date.now(),\n    };\n  }\n\n  throttleAdd(\n    patches: Patch[],\n    inversePatches: Patch[],\n    throttleRate: number = 500\n  ) {\n    if (patches.length === 0 && inversePatches.length === 0) {\n      return;\n    }\n\n    if (this.timeline.length && this.pointer >= 0) {\n      const {\n        patches: currPatches,\n        inversePatches: currInversePatches,\n        timestamp,\n      } = this.timeline[this.pointer];\n\n      const now = new Date();\n      const diff = now.getTime() - timestamp;\n\n      if (diff < throttleRate) {\n        this.timeline[this.pointer] = {\n          timestamp,\n          patches: [...currPatches, ...patches],\n          inversePatches: [...inversePatches, ...currInversePatches],\n        };\n        return;\n      }\n    }\n\n    this.add(patches, inversePatches);\n  }\n\n  merge(patches: Patch[], inversePatches: Patch[]) {\n    if (patches.length === 0 && inversePatches.length === 0) {\n      return;\n    }\n\n    if (this.timeline.length && this.pointer >= 0) {\n      const {\n        patches: currPatches,\n        inversePatches: currInversePatches,\n        timestamp,\n      } = this.timeline[this.pointer];\n\n      this.timeline[this.pointer] = {\n        timestamp,\n        patches: [...currPatches, ...patches],\n        inversePatches: [...inversePatches, ...currInversePatches],\n      };\n      return;\n    }\n\n    this.add(patches, inversePatches);\n  }\n\n  clear() {\n    this.timeline = [];\n    this.pointer = -1;\n  }\n\n  canUndo() {\n    return this.pointer >= 0;\n  }\n\n  canRedo() {\n    return this.pointer < this.timeline.length - 1;\n  }\n\n  undo(state) {\n    if (!this.canUndo()) {\n      return;\n    }\n\n    const { inversePatches } = this.timeline[this.pointer];\n    this.pointer = this.pointer - 1;\n    return applyPatches(state, inversePatches);\n  }\n\n  redo(state) {\n    if (!this.canRedo()) {\n      return;\n    }\n\n    this.pointer = this.pointer + 1;\n    const { patches } = this.timeline[this.pointer];\n    return applyPatches(state, patches);\n  }\n}\n","// https://github.com/pelotom/use-methods\nimport produce, {\n  Patch,\n  produceWithPatches,\n  enableMapSet,\n  enablePatches,\n} from 'immer';\nimport isEqualWith from 'lodash/isEqualWith';\nimport { useMemo, useEffect, useRef, useCallback } from 'react';\n\nimport { History, HISTORY_ACTIONS } from './History';\nimport { Delete } from './utilityTypes';\n\nenableMapSet();\nenablePatches();\n\nexport type SubscriberAndCallbacksFor<\n  M extends MethodsOrOptions,\n  Q extends QueryMethods = any\n> = {\n  subscribe: Watcher<StateFor<M>>['subscribe'];\n  getState: () => { prev: StateFor<M>; current: StateFor<M> };\n  actions: CallbacksFor<M>;\n  query: QueryCallbacksFor<Q>;\n  history: History;\n};\n\nexport type StateFor<M extends MethodsOrOptions> = M extends MethodsOrOptions<\n  infer S,\n  any\n>\n  ? S\n  : never;\n\nexport type CallbacksFor<\n  M extends MethodsOrOptions\n> = M extends MethodsOrOptions<any, infer R>\n  ? {\n      [T in ActionUnion<R>['type']]: (\n        ...payload: ActionByType<ActionUnion<R>, T>['payload']\n      ) => void;\n    } & {\n      history: {\n        undo: () => void;\n        redo: () => void;\n        clear: () => void;\n        throttle: (\n          rate?: number\n        ) => Delete<\n          {\n            [T in ActionUnion<R>['type']]: (\n              ...payload: ActionByType<ActionUnion<R>, T>['payload']\n            ) => void;\n          },\n          M extends Options ? M['ignoreHistoryForActions'][number] : never\n        >;\n        merge: () => Delete<\n          {\n            [T in ActionUnion<R>['type']]: (\n              ...payload: ActionByType<ActionUnion<R>, T>['payload']\n            ) => void;\n          },\n          M extends Options ? M['ignoreHistoryForActions'][number] : never\n        >;\n        ignore: () => Delete<\n          {\n            [T in ActionUnion<R>['type']]: (\n              ...payload: ActionByType<ActionUnion<R>, T>['payload']\n            ) => void;\n          },\n          M extends Options ? M['ignoreHistoryForActions'][number] : never\n        >;\n      };\n    }\n  : {};\n\nexport type Methods<S = any, R extends MethodRecordBase<S> = any, Q = any> = (\n  state: S,\n  query: Q\n) => R;\n\nexport type Options<S = any, R extends MethodRecordBase<S> = any, Q = any> = {\n  methods: Methods<S, R, Q>;\n  ignoreHistoryForActions: ReadonlyArray<keyof MethodRecordBase>;\n  normalizeHistory?: (state: S) => void;\n};\n\nexport type MethodsOrOptions<\n  S = any,\n  R extends MethodRecordBase<S> = any,\n  Q = any\n> = Methods<S, R, Q> | Options<S, R, Q>;\n\nexport type MethodRecordBase<S = any> = Record<\n  string,\n  (...args: any[]) => S extends object ? S | void : S\n>;\n\nexport type Action<T = any, P = any> = {\n  type: T;\n  payload?: P;\n  config?: Record<string, any>;\n};\n\nexport type ActionUnion<R extends MethodRecordBase> = {\n  [T in keyof R]: { type: T; payload: Parameters<R[T]> };\n}[keyof R];\n\nexport type ActionByType<A, T> = A extends { type: infer T2 }\n  ? T extends T2\n    ? A\n    : never\n  : never;\n\nexport type QueryMethods<\n  S = any,\n  O = any,\n  R extends MethodRecordBase<S> = any\n> = (state?: S, options?: O) => R;\nexport type QueryCallbacksFor<M extends QueryMethods> = M extends QueryMethods<\n  any,\n  any,\n  infer R\n>\n  ? {\n      [T in ActionUnion<R>['type']]: (\n        ...payload: ActionByType<ActionUnion<R>, T>['payload']\n      ) => ReturnType<R[T]>;\n    } & {\n      history: {\n        canUndo: () => boolean;\n        canRedo: () => boolean;\n      };\n    }\n  : {};\n\nexport type PatchListenerAction<M extends MethodsOrOptions> = {\n  type: keyof CallbacksFor<M>;\n  params: any;\n  patches: Patch[];\n};\n\nexport type PatchListener<\n  S,\n  M extends MethodsOrOptions,\n  Q extends QueryMethods\n> = (\n  newState: S,\n  previousState: S,\n  actionPerformedWithPatches: PatchListenerAction<M>,\n  query: QueryCallbacksFor<Q>,\n  normalizer: (cb: (draft: S) => void) => void\n) => void;\n\nexport function useMethods<S, R extends MethodRecordBase<S>>(\n  methodsOrOptions: MethodsOrOptions<S, R>, // methods to manipulate the state\n  initialState: any\n): SubscriberAndCallbacksFor<MethodsOrOptions<S, R>>;\n\nexport function useMethods<\n  S,\n  R extends MethodRecordBase<S>,\n  Q extends QueryMethods\n>(\n  methodsOrOptions: MethodsOrOptions<S, R, QueryCallbacksFor<Q>>, // methods to manipulate the state\n  initialState: any,\n  queryMethods: Q\n): SubscriberAndCallbacksFor<MethodsOrOptions<S, R>, Q>;\n\nexport function useMethods<\n  S,\n  R extends MethodRecordBase<S>,\n  Q extends QueryMethods\n>(\n  methodsOrOptions: MethodsOrOptions<S, R, QueryCallbacksFor<Q>>, // methods to manipulate the state\n  initialState: any,\n  queryMethods: Q,\n  patchListener: PatchListener<\n    S,\n    MethodsOrOptions<S, R, QueryCallbacksFor<Q>>,\n    Q\n  >\n): SubscriberAndCallbacksFor<MethodsOrOptions<S, R>, Q>;\n\nexport function useMethods<\n  S,\n  R extends MethodRecordBase<S>,\n  Q extends QueryMethods = null\n>(\n  methodsOrOptions: MethodsOrOptions<S, R>,\n  initialState: any,\n  queryMethods?: Q,\n  patchListener?: any\n): SubscriberAndCallbacksFor<MethodsOrOptions<S, R>, Q> {\n  const history = useMemo(() => new History(), []);\n\n  let methodsFactory: Methods<S, R>;\n  let ignoreHistoryForActionsRef = useRef([]);\n  let normalizeHistoryRef = useRef<any>(() => {});\n\n  if (typeof methodsOrOptions === 'function') {\n    methodsFactory = methodsOrOptions;\n  } else {\n    methodsFactory = methodsOrOptions.methods;\n    ignoreHistoryForActionsRef.current = methodsOrOptions.ignoreHistoryForActions as any;\n    normalizeHistoryRef.current = methodsOrOptions.normalizeHistory;\n  }\n\n  const patchListenerRef = useRef(patchListener);\n  patchListenerRef.current = patchListener;\n\n  const stateRef = useRef(initialState);\n\n  const reducer = useMemo(() => {\n    const { current: normalizeHistory } = normalizeHistoryRef;\n    const { current: ignoreHistoryForActions } = ignoreHistoryForActionsRef;\n    const { current: patchListener } = patchListenerRef;\n\n    return (state: S, action: Action) => {\n      const query =\n        queryMethods && createQuery(queryMethods, () => state, history);\n\n      let finalState;\n      let [nextState, patches, inversePatches] = (produceWithPatches as any)(\n        state,\n        (draft: S) => {\n          switch (action.type) {\n            case HISTORY_ACTIONS.UNDO: {\n              return history.undo(draft);\n            }\n            case HISTORY_ACTIONS.REDO: {\n              return history.redo(draft);\n            }\n            case HISTORY_ACTIONS.CLEAR: {\n              history.clear();\n              return {\n                ...draft,\n              };\n            }\n\n            // TODO: Simplify History API\n            case HISTORY_ACTIONS.IGNORE:\n            case HISTORY_ACTIONS.MERGE:\n            case HISTORY_ACTIONS.THROTTLE: {\n              const [type, ...params] = action.payload;\n              methodsFactory(draft, query)[type](...params);\n              break;\n            }\n            default:\n              methodsFactory(draft, query)[action.type](...action.payload);\n          }\n        }\n      );\n\n      finalState = nextState;\n\n      if (patchListener) {\n        patchListener(\n          nextState,\n          state,\n          { type: action.type, params: action.payload, patches },\n          query,\n          (cb) => {\n            let normalizedDraft = produceWithPatches(nextState, cb);\n            finalState = normalizedDraft[0];\n\n            patches = [...patches, ...normalizedDraft[1]];\n            inversePatches = [...normalizedDraft[2], ...inversePatches];\n          }\n        );\n      }\n\n      if (\n        [HISTORY_ACTIONS.UNDO, HISTORY_ACTIONS.REDO].includes(\n          action.type as any\n        ) &&\n        normalizeHistory\n      ) {\n        finalState = produce(finalState, normalizeHistory);\n      }\n\n      if (\n        ![\n          ...ignoreHistoryForActions,\n          HISTORY_ACTIONS.UNDO,\n          HISTORY_ACTIONS.REDO,\n          HISTORY_ACTIONS.IGNORE,\n          HISTORY_ACTIONS.CLEAR,\n        ].includes(action.type as any)\n      ) {\n        if (action.type === HISTORY_ACTIONS.THROTTLE) {\n          history.throttleAdd(\n            patches,\n            inversePatches,\n            action.config && action.config.rate\n          );\n        } else if (action.type === HISTORY_ACTIONS.MERGE) {\n          history.merge(patches, inversePatches);\n        } else {\n          history.add(patches, inversePatches);\n        }\n      }\n\n      return finalState;\n    };\n  }, [history, methodsFactory, queryMethods]);\n\n  const getState = useCallback(() => stateRef.current, []);\n  const watcher = useMemo(() => new Watcher<S>(getState), [getState]);\n\n  const dispatch = useCallback(\n    (action: any) => {\n      const newState = reducer(stateRef.current, action);\n      stateRef.current = newState;\n      watcher.notify();\n    },\n    [reducer, watcher]\n  );\n\n  useEffect(() => {\n    watcher.notify();\n  }, [watcher]);\n\n  const query = useMemo(\n    () =>\n      !queryMethods\n        ? []\n        : createQuery(queryMethods, () => stateRef.current, history),\n    [history, queryMethods]\n  );\n\n  const actions = useMemo(() => {\n    const actionTypes = Object.keys(methodsFactory(null, null));\n\n    const { current: ignoreHistoryForActions } = ignoreHistoryForActionsRef;\n\n    return {\n      ...actionTypes.reduce((accum, type) => {\n        accum[type] = (...payload) => dispatch({ type, payload });\n        return accum;\n      }, {} as any),\n      history: {\n        undo() {\n          return dispatch({\n            type: HISTORY_ACTIONS.UNDO,\n          });\n        },\n        redo() {\n          return dispatch({\n            type: HISTORY_ACTIONS.REDO,\n          });\n        },\n        clear: () => {\n          return dispatch({\n            type: HISTORY_ACTIONS.CLEAR,\n          });\n        },\n        throttle: (rate) => {\n          return {\n            ...actionTypes\n              .filter((type) => !ignoreHistoryForActions.includes(type))\n              .reduce((accum, type) => {\n                accum[type] = (...payload) =>\n                  dispatch({\n                    type: HISTORY_ACTIONS.THROTTLE,\n                    payload: [type, ...payload],\n                    config: {\n                      rate: rate,\n                    },\n                  });\n                return accum;\n              }, {} as any),\n          };\n        },\n        ignore: () => {\n          return {\n            ...actionTypes\n              .filter((type) => !ignoreHistoryForActions.includes(type))\n              .reduce((accum, type) => {\n                accum[type] = (...payload) =>\n                  dispatch({\n                    type: HISTORY_ACTIONS.IGNORE,\n                    payload: [type, ...payload],\n                  });\n                return accum;\n              }, {} as any),\n          };\n        },\n        merge: () => {\n          return {\n            ...actionTypes\n              .filter((type) => !ignoreHistoryForActions.includes(type))\n              .reduce((accum, type) => {\n                accum[type] = (...payload) =>\n                  dispatch({\n                    type: HISTORY_ACTIONS.MERGE,\n                    payload: [type, ...payload],\n                  });\n                return accum;\n              }, {} as any),\n          };\n        },\n      },\n    };\n  }, [dispatch, methodsFactory]);\n\n  return useMemo(\n    () => ({\n      getState,\n      subscribe: (collector, cb, collectOnCreate) =>\n        watcher.subscribe(collector, cb, collectOnCreate),\n      actions,\n      query,\n      history,\n    }),\n    [actions, query, watcher, getState, history]\n  ) as any;\n}\n\nexport function createQuery<Q extends QueryMethods>(\n  queryMethods: Q,\n  getState,\n  history: History\n) {\n  const queries = Object.keys(queryMethods()).reduce((accum, key) => {\n    return {\n      ...accum,\n      [key]: (...args: any) => {\n        return queryMethods(getState())[key](...args);\n      },\n    };\n  }, {} as QueryCallbacksFor<typeof queryMethods>);\n\n  return {\n    ...queries,\n    history: {\n      canUndo: () => history.canUndo(),\n      canRedo: () => history.canRedo(),\n    },\n  };\n}\n\nclass Watcher<S> {\n  getState;\n  subscribers: Subscriber[] = [];\n\n  constructor(getState) {\n    this.getState = getState;\n  }\n\n  /**\n   * Creates a Subscriber\n   * @returns {() => void} a Function that removes the Subscriber\n   */\n  subscribe<C>(\n    collector: (state: S) => C,\n    onChange: (collected: C) => void,\n    collectOnCreate?: boolean\n  ): () => void {\n    const subscriber = new Subscriber(\n      () => collector(this.getState()),\n      onChange,\n      collectOnCreate\n    );\n    this.subscribers.push(subscriber);\n    return this.unsubscribe.bind(this, subscriber);\n  }\n\n  unsubscribe(subscriber) {\n    if (this.subscribers.length) {\n      const index = this.subscribers.indexOf(subscriber);\n      if (index > -1) return this.subscribers.splice(index, 1);\n    }\n  }\n\n  notify() {\n    this.subscribers.forEach((subscriber) => subscriber.collect());\n  }\n}\n\nclass Subscriber {\n  collected: any;\n  collector: () => any;\n  onChange: (collected: any) => void;\n  id;\n\n  /**\n   * Creates a Subscriber\n   * @param collector The method that returns an object of values to be collected\n   * @param onChange A callback method that is triggered when the collected values has changed\n   * @param collectOnCreate If set to true, the collector/onChange will be called on instantiation\n   */\n  constructor(collector, onChange, collectOnCreate = false) {\n    this.collector = collector;\n    this.onChange = onChange;\n\n    // Collect and run onChange callback when Subscriber is created\n    if (collectOnCreate) this.collect();\n  }\n\n  collect() {\n    try {\n      const recollect = this.collector();\n      if (!isEqualWith(recollect, this.collected)) {\n        this.collected = recollect;\n        if (this.onChange) this.onChange(this.collected);\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.warn(err);\n    }\n  }\n}\n","export const getDOMInfo = (el: HTMLElement) => {\n  const {\n    x,\n    y,\n    top,\n    left,\n    bottom,\n    right,\n    width,\n    height,\n  } = el.getBoundingClientRect() as DOMRect;\n\n  const style = window.getComputedStyle(el);\n\n  const margin = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight),\n    bottom: parseInt(style.marginBottom),\n    top: parseInt(style.marginTop),\n  };\n\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight),\n    bottom: parseInt(style.paddingBottom),\n    top: parseInt(style.paddingTop),\n  };\n\n  const styleInFlow = (parent: HTMLElement) => {\n    const parentStyle: any = getComputedStyle(parent);\n\n    if (style.overflow && style.overflow !== 'visible') {\n      return;\n    }\n\n    if (parentStyle.float !== 'none') {\n      return;\n    }\n\n    if (parentStyle.display === 'grid') {\n      return;\n    }\n\n    if (\n      parentStyle.display === 'flex' &&\n      parentStyle['flex-direction'] !== 'column'\n    ) {\n      return;\n    }\n\n    switch (style.position) {\n      case 'static':\n      case 'relative':\n        break;\n      default:\n        return;\n    }\n\n    switch (el.tagName) {\n      case 'TR':\n      case 'TBODY':\n      case 'THEAD':\n      case 'TFOOT':\n        return true;\n    }\n\n    switch (style.display) {\n      case 'block':\n      case 'list-item':\n      case 'table':\n      case 'flex':\n      case 'grid':\n        return true;\n    }\n\n    return;\n  };\n\n  return {\n    x,\n    y,\n    top,\n    left,\n    bottom,\n    right,\n    width,\n    height,\n    outerWidth: Math.round(width + margin.left + margin.right),\n    outerHeight: Math.round(height + margin.top + margin.bottom),\n    margin,\n    padding,\n    inFlow: el.parentElement && !!styleInFlow(el.parentElement),\n  };\n};\n","import { useState, useCallback, useRef, useEffect } from 'react';\n\nimport { SubscriberAndCallbacksFor } from './useMethods';\nimport { ConditionallyMergeRecordTypes } from './utilityTypes';\n\ntype CollectorMethods<S extends SubscriberAndCallbacksFor<any, any>> = {\n  actions: S['actions'];\n  query: S['query'];\n};\n\nexport type useCollectorReturnType<\n  S extends SubscriberAndCallbacksFor<any, any>,\n  C = null\n> = ConditionallyMergeRecordTypes<C, CollectorMethods<S>>;\nexport function useCollector<S extends SubscriberAndCallbacksFor<any, any>, C>(\n  store: S,\n  collector?: (\n    state: ReturnType<S['getState']>['current'],\n    query: S['query']\n  ) => C\n): useCollectorReturnType<S, C> {\n  const { subscribe, getState, actions, query } = store;\n\n  const initial = useRef(true);\n  const collected = useRef<any>(null);\n  const collectorRef = useRef(collector);\n  collectorRef.current = collector;\n\n  const onCollect = useCallback(\n    (collected) => {\n      return { ...collected, actions, query };\n    },\n    [actions, query]\n  );\n\n  // Collect states for initial render\n  if (initial.current && collector) {\n    collected.current = collector(getState(), query);\n    initial.current = false;\n  }\n\n  const [renderCollected, setRenderCollected] = useState(\n    onCollect(collected.current)\n  );\n\n  // Collect states on state change\n  useEffect(() => {\n    let unsubscribe;\n    if (collectorRef.current) {\n      unsubscribe = subscribe(\n        (current) => collectorRef.current(current, query),\n        (collected) => {\n          setRenderCollected(onCollect(collected));\n        }\n      );\n    }\n    return () => {\n      if (unsubscribe) unsubscribe();\n    };\n  }, [onCollect, query, subscribe]);\n\n  return renderCollected;\n}\n","import { nanoid } from 'nanoid';\n\n// By default nanoid generate an ID with 21 characters. To reduce the footprint, we default to 10 characters.\n// We have a higher probability for collisions, though\n\n/**\n * Generate a random ID. That ID can for example be used as a node ID.\n *\n * @param size The number of characters that are generated for the ID. Defaults to `10`\n * @returns A random id\n */\nexport const getRandomId = (size: number = 10) => nanoid(size);\n","import isEqual from 'shallowequal';\n\nimport { ConnectorToRegister, RegisteredConnector } from './interfaces';\n\nimport { getRandomId } from '../getRandomId';\n\n/**\n * Stores all connected DOM elements and their connectors here\n * This allows us to easily enable/disable and perform cleanups\n */\nexport class ConnectorRegistry {\n  private isEnabled: boolean = true;\n\n  private elementIdMap: WeakMap<HTMLElement, string> = new WeakMap();\n  private registry: Map<String, RegisteredConnector> = new Map();\n\n  private getElementId(element: HTMLElement) {\n    const existingId = this.elementIdMap.get(element);\n    if (existingId) {\n      return existingId;\n    }\n\n    const newId = getRandomId();\n\n    this.elementIdMap.set(element, newId);\n    return newId;\n  }\n\n  getConnectorId(element: HTMLElement, connectorName: string) {\n    const elementId = this.getElementId(element);\n    return `${connectorName}--${elementId}`;\n  }\n\n  register(element: HTMLElement, connectorPayload: ConnectorToRegister) {\n    const existingConnector = this.getByElement(element, connectorPayload.name);\n\n    if (existingConnector) {\n      if (isEqual(connectorPayload.required, existingConnector.required)) {\n        return existingConnector;\n      }\n\n      this.getByElement(element, connectorPayload.name).disable();\n    }\n\n    let cleanup: () => void | null = null;\n\n    const id = this.getConnectorId(element, connectorPayload.name);\n    this.registry.set(id, {\n      id,\n      required: connectorPayload.required,\n      enable: () => {\n        if (cleanup) {\n          cleanup();\n        }\n\n        cleanup = connectorPayload.connector(\n          element,\n          connectorPayload.required,\n          connectorPayload.options\n        );\n      },\n      disable: () => {\n        if (!cleanup) {\n          return;\n        }\n\n        cleanup();\n      },\n      remove: () => {\n        return this.remove(id);\n      },\n    });\n\n    if (this.isEnabled) {\n      this.registry.get(id).enable();\n    }\n\n    return this.registry.get(id);\n  }\n\n  get(id: string) {\n    return this.registry.get(id);\n  }\n\n  remove(id: string) {\n    const connector = this.get(id);\n    if (!connector) {\n      return;\n    }\n\n    connector.disable();\n    this.registry.delete(connector.id);\n  }\n\n  enable() {\n    this.isEnabled = true;\n    this.registry.forEach((connectors) => {\n      connectors.enable();\n    });\n  }\n\n  disable() {\n    this.isEnabled = false;\n    this.registry.forEach((connectors) => {\n      connectors.disable();\n    });\n  }\n\n  getByElement(element: HTMLElement, connectorName: string) {\n    return this.get(this.getConnectorId(element, connectorName));\n  }\n\n  removeByElement(element: HTMLElement, connectorName: string) {\n    return this.remove(this.getConnectorId(element, connectorName));\n  }\n\n  clear() {\n    this.disable();\n    this.elementIdMap = new WeakMap();\n    this.registry = new Map();\n  }\n}\n","import { EventHandlers } from './EventHandlers';\n\nexport type Connector = (el: HTMLElement, ...args: any) => any;\n\nexport type ConnectorsRecord = Record<string, Connector>;\n\nexport type ChainableConnector<T extends Connector, O extends any> = T extends (\n  element: infer E,\n  ...args: infer P\n) => any\n  ? <B extends E | O>(element: B, ...args: P) => B\n  : never;\n\nexport type ChainableConnectors<\n  H extends ConnectorsRecord,\n  E extends any = HTMLElement\n> = {\n  [T in keyof H]: H[T] extends Connector ? ChainableConnector<H[T], E> : never;\n};\n\nexport type CraftDOMEvent<T extends Event> = T & {\n  craft: {\n    stopPropagation: () => void;\n    blockedEvents: Record<string, HTMLElement[]>;\n  };\n};\n\nexport type CraftEventListener<K extends keyof HTMLElementEventMap> = (\n  ev: CraftDOMEvent<HTMLElementEventMap[K]>\n) => any;\n\nexport type EventHandlerConnectors<\n  H extends EventHandlers,\n  E extends any = HTMLElement\n> = ChainableConnectors<ReturnType<H['handlers']>, E>;\n\nexport type ConnectorsUsage<H extends EventHandlers> = {\n  register: () => void;\n  cleanup: () => void;\n  connectors: EventHandlerConnectors<H>;\n};\n\nexport enum EventHandlerUpdates {\n  HandlerDisabled,\n  HandlerEnabled,\n}\n\nexport type ConnectorToRegister = {\n  name: string;\n  required: any;\n  connector: Connector;\n  options?: Record<string, any>;\n};\n\nexport type RegisteredConnector = {\n  id: string;\n  required: any;\n  enable: () => void;\n  disable: () => void;\n  remove: () => void;\n};\n","import { ConnectorRegistry } from './ConnectorRegistry';\nimport {\n  EventHandlerUpdates,\n  CraftEventListener,\n  EventHandlerConnectors,\n  CraftDOMEvent,\n  Connector,\n  ConnectorsUsage,\n  RegisteredConnector,\n} from './interfaces';\nimport { isEventBlockedByDescendant } from './isEventBlockedByDescendant';\n\nexport abstract class EventHandlers<O extends Record<string, any> = {}> {\n  options: O;\n\n  private registry: ConnectorRegistry = new ConnectorRegistry();\n  private subscribers: Set<(msg: EventHandlerUpdates) => void> = new Set();\n\n  onEnable?(): void;\n  onDisable?(): void;\n\n  constructor(options?: O) {\n    this.options = options;\n  }\n\n  listen(cb: (msg: EventHandlerUpdates) => void) {\n    this.subscribers.add(cb);\n    return () => this.subscribers.delete(cb);\n  }\n\n  disable() {\n    if (this.onDisable) {\n      this.onDisable();\n    }\n\n    this.registry.disable();\n\n    this.subscribers.forEach((listener) => {\n      listener(EventHandlerUpdates.HandlerDisabled);\n    });\n  }\n\n  enable() {\n    if (this.onEnable) {\n      this.onEnable();\n    }\n\n    this.registry.enable();\n\n    this.subscribers.forEach((listener) => {\n      listener(EventHandlerUpdates.HandlerEnabled);\n    });\n  }\n\n  cleanup() {\n    this.disable();\n    this.subscribers.clear();\n    this.registry.clear();\n  }\n\n  addCraftEventListener<K extends keyof HTMLElementEventMap>(\n    el: HTMLElement,\n    eventName: K,\n    listener: CraftEventListener<K>,\n    options?: boolean | AddEventListenerOptions\n  ) {\n    const bindedListener = (e: CraftDOMEvent<HTMLElementEventMap[K]>) => {\n      if (!isEventBlockedByDescendant(e, eventName, el)) {\n        e.craft.stopPropagation = () => {\n          if (!e.craft.blockedEvents[eventName]) {\n            e.craft.blockedEvents[eventName] = [];\n          }\n\n          e.craft.blockedEvents[eventName].push(el);\n        };\n\n        listener(e);\n      }\n    };\n\n    el.addEventListener(eventName, bindedListener, options);\n\n    return () => el.removeEventListener(eventName, bindedListener, options);\n  }\n\n  // Defines the connectors and their logic\n  abstract handlers(): Record<string, (el: HTMLElement, ...args: any[]) => any>;\n\n  /**\n   * Creates a record of chainable connectors and tracks their usages\n   */\n  createConnectorsUsage(): ConnectorsUsage<this> {\n    const handlers = this.handlers();\n\n    // Track all active connector ids here\n    // This is so we can return a cleanup method below so the callee can programmatically cleanup all connectors\n\n    const activeConnectorIds: Set<string> = new Set();\n\n    let canRegisterConnectors = false;\n    const connectorsToRegister: Map<\n      string,\n      () => RegisteredConnector\n    > = new Map();\n\n    const connectors = Object.entries(handlers).reduce<\n      Record<string, Connector>\n    >(\n      (accum, [name, handler]) => ({\n        ...accum,\n        [name]: (el, required, options) => {\n          const registerConnector = () => {\n            const connector = this.registry.register(el, {\n              required,\n              name,\n              options,\n              connector: handler,\n            });\n\n            activeConnectorIds.add(connector.id);\n            return connector;\n          };\n\n          connectorsToRegister.set(\n            this.registry.getConnectorId(el, name),\n            registerConnector\n          );\n\n          /**\n           * If register() has been called,\n           * register the connector immediately.\n           *\n           * Otherwise, registration is deferred until after register() is called\n           */\n          if (canRegisterConnectors) {\n            registerConnector();\n          }\n\n          return el;\n        },\n      }),\n      {}\n    ) as any;\n\n    return {\n      connectors,\n      register: () => {\n        canRegisterConnectors = true;\n\n        connectorsToRegister.forEach((registerConnector) => {\n          registerConnector();\n        });\n      },\n      cleanup: () => {\n        canRegisterConnectors = false;\n\n        activeConnectorIds.forEach((connectorId) =>\n          this.registry.remove(connectorId)\n        );\n      },\n    };\n  }\n\n  derive<C extends EventHandlers>(\n    type: {\n      new (...args: any[]): C;\n    },\n    opts: C['options']\n  ) {\n    return new type(this, opts);\n  }\n\n  // This method allows us to execute multiple connectors and returns a single cleanup method for all of them\n  protected createProxyHandlers<H extends EventHandlers>(\n    instance: H,\n    cb: (connectors: EventHandlerConnectors<H>) => void\n  ) {\n    const connectorsToCleanup = [];\n    const handlers = instance.handlers();\n\n    const proxiedHandlers = new Proxy(handlers, {\n      get: (target, key: any, receiver) => {\n        if (key in handlers === false) {\n          return Reflect.get(target, key, receiver);\n        }\n\n        return (el, ...args) => {\n          const cleanup = handlers[key](el, ...args);\n          if (!cleanup) {\n            return;\n          }\n\n          connectorsToCleanup.push(cleanup);\n        };\n      },\n    });\n\n    cb(proxiedHandlers as any);\n\n    return () => {\n      connectorsToCleanup.forEach((cleanup) => {\n        cleanup();\n      });\n    };\n  }\n\n  // This lets us to execute and cleanup sibling connectors\n  reflect(cb: (connectors: EventHandlerConnectors<this>) => void) {\n    return this.createProxyHandlers(this, cb);\n  }\n}\n","import { CraftDOMEvent } from './interfaces';\n\n/**\n * Check if a specified event is blocked by a child\n * that's a descendant of the specified element\n */\nexport function isEventBlockedByDescendant<K extends keyof HTMLElementEventMap>(\n  e: CraftDOMEvent<HTMLElementEventMap[K]>,\n  eventName: K,\n  el: HTMLElement\n) {\n  // Store initial Craft event value\n  if (!e.craft) {\n    e.craft = {\n      stopPropagation: () => {},\n      blockedEvents: {},\n    };\n  }\n\n  const blockingElements = (e.craft && e.craft.blockedEvents[eventName]) || [];\n\n  for (let i = 0; i < blockingElements.length; i++) {\n    const blockingElement = blockingElements[i];\n\n    if (el !== blockingElement && el.contains(blockingElement)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { EventHandlers } from './EventHandlers';\nimport { EventHandlerConnectors, EventHandlerUpdates } from './interfaces';\n\n// Creates EventHandlers that depends on another EventHandlers instance\n// This lets us to easily create new connectors that composites of the parent EventHandlers instance\nexport abstract class DerivedEventHandlers<\n  P extends EventHandlers,\n  O extends Record<string, any> = {}\n> extends EventHandlers<O> {\n  derived: P;\n  unsubscribeParentHandlerListener: () => void;\n\n  constructor(derived: P, options?: O) {\n    super(options);\n    this.derived = derived;\n    this.options = options;\n\n    // Automatically disable/enable depending on the parent handlers\n    this.unsubscribeParentHandlerListener = this.derived.listen((msg) => {\n      switch (msg) {\n        case EventHandlerUpdates.HandlerEnabled: {\n          return this.enable();\n        }\n        case EventHandlerUpdates.HandlerDisabled: {\n          return this.disable();\n        }\n        default: {\n          return;\n        }\n      }\n    });\n  }\n\n  // A method to easily inherit parent connectors\n  inherit(cb: (connectors: EventHandlerConnectors<P>) => void) {\n    return this.createProxyHandlers(this.derived, cb);\n  }\n\n  cleanup() {\n    super.cleanup();\n    this.unsubscribeParentHandlerListener();\n  }\n}\n","// https://github.com/react-dnd/react-dnd\nimport { isValidElement, ReactElement } from 'react';\nimport { cloneElement } from 'react';\nimport invariant from 'tiny-invariant';\n\nimport { ChainableConnectors, ConnectorsRecord } from './interfaces';\n\nfunction setRef(ref: any, node: any) {\n  if (node) {\n    if (typeof ref === 'function') {\n      ref(node);\n    } else {\n      ref.current = node;\n    }\n  }\n}\n\nexport function cloneWithRef(\n  element: any,\n  newRef: any\n): React.ReactElement<any> {\n  const previousRef = element.ref;\n  invariant(\n    typeof previousRef !== 'string',\n    'Cannot connect to an element with an existing string ref. ' +\n      'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' +\n      'Read more: https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute'\n  );\n\n  if (!previousRef) {\n    // When there is no ref on the element, use the new ref directly\n    return cloneElement(element, {\n      ref: newRef,\n    });\n  } else {\n    return cloneElement(element, {\n      ref: (node: any) => {\n        setRef(previousRef, node);\n        setRef(newRef, node);\n      },\n    });\n  }\n}\n\nfunction throwIfCompositeComponentElement(element: React.ReactElement<any>) {\n  if (typeof element.type === 'string') {\n    return;\n  }\n\n  throw new Error();\n}\n\nexport function wrapHookToRecognizeElement(\n  hook: (node: any, ...args: any[]) => void\n) {\n  return (elementOrNode = null, ...args: any) => {\n    // When passed a node, call the hook straight away.\n    if (!isValidElement(elementOrNode)) {\n      if (!elementOrNode) {\n        return;\n      }\n\n      const node = elementOrNode;\n      node && hook(node, ...args);\n      return node;\n    }\n\n    // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n    const element: ReactElement | null = elementOrNode;\n    throwIfCompositeComponentElement(element as any);\n\n    return cloneWithRef(element, hook);\n  };\n}\n\n// A React wrapper for our connectors\n// Wrap all our connectors so that would additionally accept React.ReactElement\nexport function wrapConnectorHooks<H extends ConnectorsRecord>(\n  connectors: H\n): ChainableConnectors<H, React.ReactElement | HTMLElement> {\n  return Object.keys(connectors).reduce((accum, key) => {\n    accum[key] = wrapHookToRecognizeElement((...args) => {\n      // @ts-ignore\n      return connectors[key](...args);\n    });\n\n    return accum;\n  }, {}) as any;\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\ntype RenderIndicatorProps = {\n  style: React.CSSProperties;\n  className?: string;\n  parentDom?: HTMLElement;\n};\n\nexport const RenderIndicator = ({\n  style,\n  className,\n  parentDom,\n}: RenderIndicatorProps) => {\n  const indicator = (\n    <div\n      className={className}\n      style={{\n        position: 'fixed',\n        display: 'block',\n        opacity: 1,\n        borderStyle: 'solid',\n        borderWidth: '1px',\n        borderColor: 'transparent',\n        zIndex: 99999,\n        ...style,\n      }}\n    ></div>\n  );\n\n  if (parentDom && parentDom.ownerDocument !== document) {\n    return ReactDOM.createPortal(indicator, parentDom.ownerDocument.body);\n  }\n\n  return indicator;\n};\n","import { useEffect } from 'react';\n\nexport const useEffectOnce = (effect: () => void) => {\n  /* eslint-disable-next-line react-hooks/exhaustive-deps */\n  useEffect(effect, []);\n};\n","type DeprecationPayload = Partial<{\n  suggest: string;\n  doc: string;\n}>;\n\nexport const deprecationWarning = (name, payload?: DeprecationPayload) => {\n  let message = `Deprecation warning: ${name} will be deprecated in future relases.`;\n\n  const { suggest, doc } = payload;\n\n  if (suggest) {\n    message += ` Please use ${suggest} instead.`;\n  }\n\n  // URL link to Documentation\n  if (doc) {\n    message += `(${doc})`;\n  }\n\n  // eslint-disable-next-line no-console\n  console.warn(message);\n};\n","export const isClientSide = () => typeof window !== 'undefined';\n\nexport const isLinux = () =>\n  isClientSide() && /Linux/i.test(window.navigator.userAgent);\n\nexport const isChromium = () =>\n  isClientSide() && /Chrome/i.test(window.navigator.userAgent);\n"],"names":["ROOT_NODE","DEPRECATED_ROOT_NODE","ERROR_NOPARENT","ERROR_DUPLICATE_NODEID","ERROR_INVALID_NODEID","ERROR_TOP_LEVEL_ELEMENT_NO_ID","ERROR_MISSING_PLACEHOLDER_PLACEMENT","ERROR_MOVE_CANNOT_DROP","ERROR_MOVE_INCOMING_PARENT","ERROR_MOVE_OUTGOING_PARENT","ERROR_MOVE_NONCANVAS_CHILD","ERROR_MOVE_TO_NONCANVAS_PARENT","ERROR_MOVE_TOP_LEVEL_NODE","ERROR_MOVE_ROOT_NODE","ERROR_MOVE_TO_DESCENDANT","ERROR_NOT_IN_RESOLVER","ERROR_INFINITE_CANVAS","ERROR_CANNOT_DRAG","ERROR_INVALID_NODE_ID","ERROR_DELETE_TOP_LEVEL_NODE","ERROR_RESOLVER_NOT_AN_OBJECT","ERROR_DESERIALIZE_COMPONENT_NOT_IN_RESOLVER","ERROR_USE_EDITOR_OUTSIDE_OF_EDITOR_CONTEXT","ERROR_USE_NODE_OUTSIDE_OF_EDITOR_CONTEXT","HISTORY_ACTIONS","UNDO","REDO","THROTTLE","IGNORE","MERGE","CLEAR","History","constructor","_defineProperty","this","add","patches","inversePatches","length","pointer","timeline","timestamp","Date","now","throttleAdd","throttleRate","currPatches","currInversePatches","getTime","merge","clear","canUndo","canRedo","undo","state","applyPatches","redo","useMethods","methodsOrOptions","initialState","queryMethods","patchListener","history","useMemo","methodsFactory","ignoreHistoryForActionsRef","useRef","normalizeHistoryRef","methods","current","ignoreHistoryForActions","normalizeHistory","patchListenerRef","stateRef","reducer","action","query","createQuery","finalState","nextState","produceWithPatches","draft","type","_objectSpread","params","payload","cb","normalizedDraft","includes","produce","config","rate","getState","useCallback","watcher","Watcher","dispatch","newState","notify","useEffect","actions","actionTypes","Object","keys","reduce","accum","_len","arguments","Array","_key","throttle","filter","_len2","_key2","ignore","_len3","_key3","_len4","_key4","subscribe","collector","collectOnCreate","queries","key","enableMapSet","enablePatches","onChange","subscriber","Subscriber","subscribers","push","unsubscribe","bind","index","indexOf","splice","forEach","collect","undefined","recollect","isEqualWith","collected","err","console","warn","getDOMInfo","el","x","y","top","left","bottom","right","width","height","getBoundingClientRect","style","window","getComputedStyle","margin","parseInt","marginLeft","marginRight","marginBottom","marginTop","padding","paddingLeft","paddingRight","paddingBottom","paddingTop","outerWidth","Math","round","outerHeight","inFlow","parentElement","parent","parentStyle","overflow","float","display","position","tagName","styleInFlow","useCollector","store","initial","collectorRef","onCollect","renderCollected","setRenderCollected","useState","getRandomId","nanoid","ConnectorRegistry","WeakMap","Map","getElementId","element","existingId","elementIdMap","get","newId","set","getConnectorId","connectorName","elementId","concat","register","connectorPayload","existingConnector","getByElement","name","isEqual","required","disable","cleanup","id","registry","enable","connector","options","remove","isEnabled","delete","connectors","removeByElement","EventHandlerUpdates","EventHandlers","Set","listen","onDisable","listener","HandlerDisabled","onEnable","HandlerEnabled","addCraftEventListener","eventName","bindedListener","e","craft","stopPropagation","blockedEvents","blockingElements","i","blockingElement","contains","isEventBlockedByDescendant","addEventListener","removeEventListener","createConnectorsUsage","handlers","activeConnectorIds","canRegisterConnectors","connectorsToRegister","entries","_ref","handler","registerConnector","connectorId","derive","opts","createProxyHandlers","instance","connectorsToCleanup","proxiedHandlers","Proxy","target","receiver","Reflect","args","reflect","DerivedEventHandlers","derived","super","unsubscribeParentHandlerListener","msg","inherit","setRef","ref","node","cloneWithRef","newRef","previousRef","invariant","cloneElement","wrapHookToRecognizeElement","hook","elementOrNode","isValidElement","Error","throwIfCompositeComponentElement","wrapConnectorHooks","RenderIndicator","className","parentDom","indicator","React","createElement","opacity","borderStyle","borderWidth","borderColor","zIndex","ownerDocument","document","ReactDOM","createPortal","body","useEffectOnce","effect","deprecationWarning","message","suggest","doc","isClientSide","isLinux","test","navigator","userAgent","isChromium"],"mappings":"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"}