{"version":3,"file":"index.js","sources":["../../src/nodes/NodeContext.tsx","../../src/editor/EditorContext.tsx","../../src/events/EventContext.ts","../../src/editor/useInternalEditor.ts","../../src/nodes/useInternalNode.ts","../../src/hooks/useNode.ts","../../src/render/SimpleElement.tsx","../../src/render/DefaultRender.tsx","../../src/render/RenderNode.tsx","../../src/nodes/NodeElement.tsx","../../src/nodes/Element.tsx","../../src/nodes/Canvas.tsx","../../src/render/Frame.tsx","../../src/interfaces/nodes.ts","../../src/hooks/useEditor.tsx","../../src/utils/fromEntries.ts","../../src/utils/getNodesFromSelector.ts","../../src/editor/actions.ts","../../src/utils/removeNodeFromEvents.ts","../../src/utils/resolveComponent.ts","../../src/utils/serializeNode.tsx","../../src/editor/NodeHelpers.ts","../../src/events/findPosition.ts","../../src/utils/createNode.ts","../../src/utils/deserializeNode.tsx","../../src/utils/mergeTrees.tsx","../../src/editor/query.tsx","../../src/editor/EventHelpers.ts","../../src/utils/parseNodeFromJSX.tsx","../../src/events/CoreEventHandlers.ts","../../src/events/SnapGuideCalculator.ts","../../src/events/Positioner.ts","../../src/events/createShadow.ts","../../src/events/DefaultEventHandlers.ts","../../src/events/RenderEditorIndicator.tsx","../../src/events/movePlaceholder.ts","../../src/events/RenderSnapGuides.tsx","../../src/events/Events.tsx","../../src/editor/store.tsx","../../src/utils/testHelpers.ts","../../src/editor/Editor.tsx","../../src/hooks/legacy/connectEditor.tsx","../../src/hooks/legacy/connectNode.tsx"],"sourcesContent":["import React from 'react';\n\nimport { NodeId } from '../interfaces';\n\nexport type NodeContextType = {\n  id: NodeId;\n  related?: boolean;\n};\n\nexport const NodeContext = React.createContext<NodeContextType>(null);\n\nexport type NodeProviderProps = Omit<NodeContextType, 'connectors'> & {\n  children?: React.ReactNode;\n};\n\nexport const NodeProvider = ({\n  id,\n  related = false,\n  children,\n}: NodeProviderProps) => {\n  return (\n    <NodeContext.Provider value={{ id, related }}>\n      {children}\n    </NodeContext.Provider>\n  );\n};\n","import { createContext } from 'react';\n\nimport { EditorStore } from './store';\n\nexport type EditorContextType = EditorStore;\nexport const EditorContext = createContext<EditorContextType>(null);\n","import { createContext, useContext } from 'react';\n\nimport { CoreEventHandlers } from './CoreEventHandlers';\n\nexport const EventHandlerContext = createContext<CoreEventHandlers>(null);\n\nexport const useEventHandler = () => useContext(EventHandlerContext);\n","import {\n  useCollector,\n  useCollectorReturnType,\n  QueryCallbacksFor,\n  wrapConnectorHooks,\n  EventHandlerConnectors,\n  ERROR_USE_EDITOR_OUTSIDE_OF_EDITOR_CONTEXT,\n} from '@craftjs/utils';\nimport { useContext, useEffect, useMemo } from 'react';\nimport invariant from 'tiny-invariant';\n\nimport { EditorContext } from './EditorContext';\nimport { QueryMethods } from './query';\nimport { EditorStore } from './store';\n\nimport { CoreEventHandlers } from '../events/CoreEventHandlers';\nimport { useEventHandler } from '../events/EventContext';\nimport { EditorState } from '../interfaces';\n\nexport type EditorCollector<C> = (\n  state: EditorState,\n  query: QueryCallbacksFor<typeof QueryMethods>\n) => C;\n\nexport type useInternalEditorReturnType<C = null> = useCollectorReturnType<\n  EditorStore,\n  C\n> & {\n  inContext: boolean;\n  store: EditorStore;\n  connectors: EventHandlerConnectors<CoreEventHandlers, React.ReactElement>;\n};\n\nexport function useInternalEditor<C>(\n  collector?: EditorCollector<C>\n): useInternalEditorReturnType<C> {\n  const handler = useEventHandler();\n  const store = useContext(EditorContext);\n  invariant(store, ERROR_USE_EDITOR_OUTSIDE_OF_EDITOR_CONTEXT);\n\n  const collected = useCollector(store, collector);\n\n  const connectorsUsage = useMemo(\n    () => handler && handler.createConnectorsUsage(),\n    [handler]\n  );\n\n  useEffect(() => {\n    connectorsUsage.register();\n\n    return () => {\n      connectorsUsage.cleanup();\n    };\n  }, [connectorsUsage]);\n\n  const connectors = useMemo(\n    () => connectorsUsage && wrapConnectorHooks(connectorsUsage.connectors),\n    [connectorsUsage]\n  );\n\n  return {\n    ...collected,\n    connectors,\n    inContext: !!store,\n    store,\n  };\n}\n","import {\n  wrapConnectorHooks,\n  ERROR_USE_NODE_OUTSIDE_OF_EDITOR_CONTEXT,\n} from '@craftjs/utils';\nimport { useMemo, useContext } from 'react';\nimport invariant from 'tiny-invariant';\n\nimport { NodeContext } from './NodeContext';\n\nimport { useInternalEditor } from '../editor/useInternalEditor';\nimport { Node } from '../interfaces';\n\nexport function useInternalNode<S = null>(collect?: (node: Node) => S) {\n  const context = useContext(NodeContext);\n  invariant(context, ERROR_USE_NODE_OUTSIDE_OF_EDITOR_CONTEXT);\n\n  const { id, related } = context;\n\n  const {\n    actions: EditorActions,\n    query,\n    connectors: editorConnectors,\n    ...collected\n  } = useInternalEditor(\n    (state) => id && state.nodes[id] && collect && collect(state.nodes[id])\n  );\n\n  const connectors = useMemo(\n    () =>\n      wrapConnectorHooks({\n        connect: (dom: HTMLElement) => editorConnectors.connect(dom, id),\n        drag: (dom: HTMLElement) => editorConnectors.drag(dom, id),\n      }),\n    [editorConnectors, id]\n  );\n\n  const actions = useMemo(() => {\n    return {\n      setProp: (cb: any, throttleRate?: number) => {\n        if (throttleRate) {\n          EditorActions.history.throttle(throttleRate).setProp(id, cb);\n        } else {\n          EditorActions.setProp(id, cb);\n        }\n      },\n      setCustom: (cb: any, throttleRate?: number) => {\n        if (throttleRate) {\n          EditorActions.history.throttle(throttleRate).setCustom(id, cb);\n        } else {\n          EditorActions.setCustom(id, cb);\n        }\n      },\n      setHidden: (bool: boolean) => EditorActions.setHidden(id, bool),\n    };\n  }, [EditorActions, id]);\n\n  return {\n    ...collected,\n    id,\n    related,\n    inNodeContext: !!context,\n    actions,\n    connectors,\n  };\n}\n","import { deprecationWarning } from '@craftjs/utils';\n\nimport { Node } from '../interfaces';\nimport { useInternalNode } from '../nodes/useInternalNode';\n\n/**\n * A Hook to that provides methods and state information related to the corresponding Node that manages the current component.\n * @param collect - Collector function to consume values from the corresponding Node's state\n */\nexport function useNode<S = null>(collect?: (node: Node) => S) {\n  const {\n    id,\n    related,\n    actions,\n    inNodeContext,\n    connectors,\n    ...collected\n  } = useInternalNode(collect);\n\n  return {\n    ...collected,\n    actions,\n    id,\n    related,\n    setProp: (\n      cb: (props: Record<string, any>) => void,\n      throttleRate?: number\n    ) => {\n      deprecationWarning('useNode().setProp()', {\n        suggest: 'useNode().actions.setProp()',\n      });\n      return actions.setProp(cb, throttleRate);\n    },\n    inNodeContext,\n    connectors,\n  };\n}\n","import React from 'react';\n\nimport { useNode } from '../hooks/useNode';\n\nexport const SimpleElement = ({ render }: any) => {\n  const {\n    connectors: { connect, drag },\n  } = useNode();\n\n  return typeof render.type === 'string'\n    ? connect(drag(React.cloneElement(render)))\n    : render;\n};\n","import React, { useMemo } from 'react';\n\nimport { SimpleElement } from './SimpleElement';\n\nimport { NodeId } from '../interfaces';\nimport { NodeElement } from '../nodes/NodeElement';\nimport { useInternalNode } from '../nodes/useInternalNode';\n\nexport const DefaultRender = () => {\n  const { type, props, nodes, hydrationTimestamp } = useInternalNode(\n    (node) => ({\n      type: node.data.type,\n      props: node.data.props,\n      nodes: node.data.nodes,\n      hydrationTimestamp: node._hydrationTimestamp,\n    })\n  );\n\n  return useMemo(() => {\n    let children = props.children;\n\n    if (nodes && nodes.length > 0) {\n      children = (\n        <React.Fragment>\n          {nodes.map((id: NodeId) => (\n            <NodeElement id={id} key={id} />\n          ))}\n        </React.Fragment>\n      );\n    }\n\n    const render = React.createElement(type, props, children);\n\n    if (typeof type == 'string') {\n      return <SimpleElement render={render} />;\n    }\n\n    return render;\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\n  }, [type, props, hydrationTimestamp, nodes]);\n};\n","import React from 'react';\n\nimport { DefaultRender } from './DefaultRender';\n\nimport { useInternalEditor } from '../editor/useInternalEditor';\nimport { useInternalNode } from '../nodes/useInternalNode';\n\ntype RenderNodeToElementProps = {\n  render?: React.ReactElement;\n  children?: React.ReactNode;\n};\nexport const RenderNodeToElement = ({ render }: RenderNodeToElementProps) => {\n  const { hidden } = useInternalNode((node) => ({\n    hidden: node.data.hidden,\n  }));\n\n  const { onRender } = useInternalEditor((state) => ({\n    onRender: state.options.onRender,\n  }));\n\n  // don't display the node since it's hidden\n  if (hidden) {\n    return null;\n  }\n\n  return React.createElement(onRender, { render: render || <DefaultRender /> });\n};\n","import React from 'react';\n\nimport { NodeProvider } from './NodeContext';\n\nimport { NodeId } from '../interfaces';\nimport { RenderNodeToElement } from '../render/RenderNode';\n\nexport type NodeElementProps = {\n  id: NodeId;\n  render?: React.ReactElement;\n};\n\nexport const NodeElement = ({ id, render }: NodeElementProps) => {\n  return (\n    <NodeProvider id={id}>\n      <RenderNodeToElement render={render} />\n    </NodeProvider>\n  );\n};\n","import { ERROR_TOP_LEVEL_ELEMENT_NO_ID } from '@craftjs/utils';\nimport React, { useState } from 'react';\nimport invariant from 'tiny-invariant';\n\nimport { NodeElement } from './NodeElement';\nimport { useInternalNode } from './useInternalNode';\n\nimport { useInternalEditor } from '../editor/useInternalEditor';\nimport { NodeId } from '../interfaces';\n\nexport const defaultElementProps = {\n  is: 'div',\n  canvas: false,\n  custom: {},\n  hidden: false,\n};\n\nexport const elementPropToNodeData = {\n  is: 'type',\n  canvas: 'isCanvas',\n};\n\nexport type ElementProps<T extends React.ElementType> = {\n  id?: NodeId;\n  is?: T;\n  custom?: Record<string, any>;\n  children?: React.ReactNode;\n  canvas?: boolean;\n  hidden?: boolean;\n} & React.ComponentProps<T>;\n\nexport function Element<T extends React.ElementType>({\n  id,\n  children,\n  ...elementProps\n}: ElementProps<T>) {\n  const { is } = {\n    ...defaultElementProps,\n    ...elementProps,\n  };\n\n  const { query, actions } = useInternalEditor();\n  const { id: nodeId, inNodeContext } = useInternalNode();\n\n  const [linkedNodeId] = useState<NodeId | null>(() => {\n    invariant(!!id, ERROR_TOP_LEVEL_ELEMENT_NO_ID);\n    const node = query.node(nodeId).get();\n\n    if (inNodeContext) {\n      const existingNode = node.data.linkedNodes[id]\n        ? query.node(node.data.linkedNodes[id]).get()\n        : null;\n\n      // Render existing linked Node if it already exists (and is the same type as the JSX)\n      if (existingNode && existingNode.data.type === is) {\n        return existingNode.id;\n      }\n\n      // otherwise, create and render a new linked Node\n      const linkedElement = React.createElement(\n        Element,\n        elementProps,\n        children\n      );\n\n      const tree = query.parseReactElement(linkedElement).toNodeTree();\n\n      actions.history.ignore().addLinkedNodeFromTree(tree, nodeId, id);\n      return tree.rootNodeId;\n    }\n    return null;\n  });\n\n  return linkedNodeId ? <NodeElement id={linkedNodeId} /> : null;\n}\n","import { deprecationWarning } from '@craftjs/utils';\nimport React, { useEffect } from 'react';\n\nimport { Element, ElementProps } from './Element';\n\nexport type CanvasProps<T extends React.ElementType> = ElementProps<T>;\n\nexport const deprecateCanvasComponent = () =>\n  deprecationWarning('<Canvas />', {\n    suggest: '<Element canvas={true} />',\n  });\n\nexport function Canvas<T extends React.ElementType>({\n  ...props\n}: CanvasProps<T>) {\n  useEffect(() => deprecateCanvasComponent(), []);\n\n  return <Element {...props} canvas={true} />;\n}\n","import { deprecationWarning, ROOT_NODE } from '@craftjs/utils';\nimport React, { useRef } from 'react';\n\nimport { useInternalEditor } from '../editor/useInternalEditor';\nimport { SerializedNodes } from '../interfaces';\nimport { NodeElement } from '../nodes/NodeElement';\n\nexport type FrameProps = {\n  children?: React.ReactNode;\n  json?: string;\n  data?: string | SerializedNodes;\n};\n\nconst RenderRootNode = () => {\n  const { timestamp } = useInternalEditor((state) => ({\n    timestamp:\n      state.nodes[ROOT_NODE] && state.nodes[ROOT_NODE]._hydrationTimestamp,\n  }));\n\n  if (!timestamp) {\n    return null;\n  }\n\n  return <NodeElement id={ROOT_NODE} key={timestamp} />;\n};\n\n/**\n * A React Component that defines the editable area\n */\nexport const Frame = ({ children, json, data }: FrameProps) => {\n  const { actions, query } = useInternalEditor();\n\n  if (!!json) {\n    deprecationWarning('<Frame json={...} />', {\n      suggest: '<Frame data={...} />',\n    });\n  }\n\n  const isLoaded = useRef(false);\n\n  if (!isLoaded.current) {\n    const initialData = data || json;\n\n    if (initialData) {\n      actions.history.ignore().deserialize(initialData);\n    } else if (children) {\n      const rootNode = React.Children.only(children) as React.ReactElement;\n\n      const node = query.parseReactElement(rootNode).toNodeTree((node, jsx) => {\n        if (jsx === rootNode) {\n          node.id = ROOT_NODE;\n        }\n        return node;\n      });\n\n      actions.history.ignore().addNodeTree(node);\n    }\n\n    isLoaded.current = true;\n  }\n\n  return <RenderRootNode />;\n};\n","import { QueryCallbacksFor } from '@craftjs/utils';\nimport React from 'react';\n\nimport { QueryMethods } from '../editor/query';\n\nexport type UserComponentConfig<T> = {\n  displayName: string;\n  rules: Partial<NodeRules>;\n  related: Partial<NodeRelated>;\n  props: Partial<T>;\n  custom: Record<string, any>;\n  info: Record<string, any>;\n  isCanvas: boolean;\n\n  // TODO: Deprecate\n  name: string;\n  defaultProps: Partial<T>;\n};\n\nexport type UserComponent<T = any> = React.ComponentType<T> & {\n  craft?: Partial<UserComponentConfig<T>>;\n};\n\nexport type NodeId = string;\nexport type NodeEventTypes = 'selected' | 'dragged' | 'hovered';\n\nexport type Node = {\n  id: NodeId;\n  data: NodeData;\n  info: Record<string, any>;\n  events: Record<NodeEventTypes, boolean>;\n  dom: HTMLElement | null;\n  related: Record<string, React.ElementType>;\n  rules: NodeRules;\n  _hydrationTimestamp: number;\n};\n\nexport type NodeHelpersType = QueryCallbacksFor<typeof QueryMethods>['node'];\nexport type NodeRules = {\n  canDrag(node: Node, helpers: NodeHelpersType): boolean;\n  canDrop(dropTarget: Node, self: Node, helpers: NodeHelpersType): boolean;\n  canMoveIn(canMoveIn: Node[], self: Node, helpers: NodeHelpersType): boolean;\n  canMoveOut(canMoveOut: Node[], self: Node, helpers: NodeHelpersType): boolean;\n};\nexport type NodeRelated = Record<string, React.ElementType>;\n\nexport type NodeData = {\n  props: Record<string, any>;\n  type: string | React.ElementType;\n  name: string;\n  displayName: string;\n  isCanvas: boolean;\n  parent: NodeId | null;\n  linkedNodes: Record<string, NodeId>;\n  nodes: NodeId[];\n  hidden: boolean;\n  custom?: any;\n  _childCanvas?: Record<string, NodeId>; // TODO: Deprecate in favour of linkedNodes\n};\n\nexport type FreshNode = {\n  id?: NodeId;\n  data: Partial<NodeData> & Required<Pick<NodeData, 'type'>>;\n};\n\nexport type ReduceCompType =\n  | string\n  | {\n      resolvedName: string;\n    };\n\nexport type ReducedComp = {\n  type: ReduceCompType;\n  isCanvas: boolean;\n  props: any;\n};\n\nexport type SerializedNode = Omit<\n  NodeData,\n  'type' | 'subtype' | 'name' | 'event'\n> &\n  ReducedComp;\n\nexport type SerializedNodes = Record<NodeId, SerializedNode>;\n\n// TODO: Deprecate in favor of SerializedNode\nexport type SerializedNodeData = SerializedNode;\n\nexport type Nodes = Record<NodeId, Node>;\n\n/**\n * A NodeTree is an internal data structure for CRUD operations that involve\n * more than a single node.\n *\n * For example, when we drop a component we use a tree because we\n * need to drop more than a single component.\n */\nexport interface NodeTree {\n  rootNodeId: NodeId;\n  nodes: Nodes;\n}\n\ntype NodeIdSelector = NodeId | NodeId[];\ntype NodeObjSelector = Node | Node[];\n\nexport enum NodeSelectorType {\n  Any,\n  Id,\n  Obj,\n}\n\nexport type NodeSelector<\n  T extends NodeSelectorType = NodeSelectorType.Any\n> = T extends NodeSelectorType.Id\n  ? NodeIdSelector\n  : T extends NodeSelectorType.Obj\n  ? NodeObjSelector\n  : NodeIdSelector | NodeObjSelector;\n\nexport type NodeSelectorWrapper = {\n  node: Node;\n  exists: boolean;\n};\n","import { Overwrite, Delete, OverwriteFnReturnType } from '@craftjs/utils';\nimport { useMemo } from 'react';\n\nimport {\n  useInternalEditor,\n  EditorCollector,\n  useInternalEditorReturnType,\n} from '../editor/useInternalEditor';\n\ntype PrivateActions =\n  | 'addLinkedNodeFromTree'\n  | 'setNodeEvent'\n  | 'setDOM'\n  | 'replaceNodes'\n  | 'reset';\n\nconst getPublicActions = (actions) => {\n  const {\n    addLinkedNodeFromTree,\n    setDOM,\n    setNodeEvent,\n    replaceNodes,\n    reset,\n    ...EditorActions\n  } = actions;\n\n  return EditorActions;\n};\n\nexport type WithoutPrivateActions<S = null> = Delete<\n  useInternalEditorReturnType<S>['actions'],\n  PrivateActions | 'history'\n> & {\n  history: Overwrite<\n    useInternalEditorReturnType<S>['actions']['history'],\n    {\n      ignore: OverwriteFnReturnType<\n        useInternalEditorReturnType<S>['actions']['history']['ignore'],\n        PrivateActions\n      >;\n      throttle: OverwriteFnReturnType<\n        useInternalEditorReturnType<S>['actions']['history']['throttle'],\n        PrivateActions\n      >;\n    }\n  >;\n};\n\nexport type useEditorReturnType<S = null> = Overwrite<\n  useInternalEditorReturnType<S>,\n  {\n    actions: WithoutPrivateActions;\n    query: Delete<useInternalEditorReturnType<S>['query'], 'deserialize'>;\n  }\n>;\n\n/**\n * A Hook that that provides methods and information related to the entire editor state.\n * @param collector Collector function to consume values from the editor's state\n */\nexport function useEditor(): useEditorReturnType;\nexport function useEditor<S>(\n  collect: EditorCollector<S>\n): useEditorReturnType<S>;\n\nexport function useEditor<S>(collect?: any): useEditorReturnType<S> {\n  const {\n    connectors,\n    actions: internalActions,\n    query,\n    store,\n    ...collected\n  } = useInternalEditor(collect);\n\n  const EditorActions = getPublicActions(internalActions);\n\n  const actions = useMemo(() => {\n    return {\n      ...EditorActions,\n      history: {\n        ...EditorActions.history,\n        ignore: (...args) =>\n          getPublicActions(EditorActions.history.ignore(...args)),\n        throttle: (...args) =>\n          getPublicActions(EditorActions.history.throttle(...args)),\n      },\n    };\n  }, [EditorActions]);\n\n  return {\n    connectors,\n    actions,\n    query,\n    store,\n    ...(collected as any),\n  };\n}\n","export const fromEntries = (pairs) => {\n  if (Object.fromEntries) {\n    return Object.fromEntries(pairs);\n  }\n  return pairs.reduce(\n    (accum, [id, value]) => ({\n      ...accum,\n      [id]: value,\n    }),\n    {}\n  );\n};\n","import { ERROR_INVALID_NODEID } from '@craftjs/utils';\nimport invariant from 'tiny-invariant';\n\nimport { Nodes, Node, NodeSelectorWrapper, NodeSelector } from '../interfaces';\n\ntype config = { existOnly: boolean; idOnly: boolean };\nexport const getNodesFromSelector = (\n  nodes: Nodes,\n  selector: NodeSelector,\n  config?: Partial<config>\n): NodeSelectorWrapper[] => {\n  const items = Array.isArray(selector) ? selector : [selector];\n\n  const mergedConfig = {\n    existOnly: false,\n    idOnly: false,\n    ...(config || {}),\n  };\n\n  const nodeSelectors = items\n    .filter((item) => !!item)\n    .map((item) => {\n      if (typeof item === 'string') {\n        return {\n          node: nodes[item],\n          exists: !!nodes[item],\n        };\n      }\n\n      if (typeof item === 'object' && !mergedConfig.idOnly) {\n        const node = item as Node;\n        return {\n          node,\n          exists: !!nodes[node.id],\n        };\n      }\n\n      return {\n        node: null,\n        exists: false,\n      };\n    });\n\n  if (mergedConfig.existOnly) {\n    invariant(\n      nodeSelectors.filter((selector) => !selector.exists).length === 0,\n      ERROR_INVALID_NODEID\n    );\n  }\n\n  return nodeSelectors;\n};\n","import {\n  deprecationWarning,\n  ERROR_INVALID_NODEID,\n  ROOT_NODE,\n  DEPRECATED_ROOT_NODE,\n  QueryCallbacksFor,\n  ERROR_NOPARENT,\n  ERROR_DELETE_TOP_LEVEL_NODE,\n  CallbacksFor,\n  Delete,\n  ERROR_NOT_IN_RESOLVER,\n} from '@craftjs/utils';\nimport invariant from 'tiny-invariant';\n\nimport { QueryMethods } from './query';\n\nimport {\n  EditorState,\n  Indicator,\n  NodeId,\n  Node,\n  Nodes,\n  Options,\n  NodeEventTypes,\n  NodeTree,\n  SerializedNodes,\n  NodeSelector,\n  NodeSelectorType,\n} from '../interfaces';\nimport { fromEntries } from '../utils/fromEntries';\nimport { getNodesFromSelector } from '../utils/getNodesFromSelector';\nimport { removeNodeFromEvents } from '../utils/removeNodeFromEvents';\n\nconst Methods = (\n  state: EditorState,\n  query: QueryCallbacksFor<typeof QueryMethods>\n) => {\n  /** Helper functions */\n  const addNodeTreeToParent = (\n    tree: NodeTree,\n    parentId?: NodeId,\n    addNodeType?:\n      | {\n          type: 'child';\n          index: number;\n        }\n      | {\n          type: 'linked';\n          id: string;\n        }\n  ) => {\n    const iterateChildren = (id: NodeId, parentId?: NodeId) => {\n      const node = tree.nodes[id];\n\n      if (typeof node.data.type !== 'string') {\n        invariant(\n          state.options.resolver[node.data.name],\n          ERROR_NOT_IN_RESOLVER.replace(\n            '%node_type%',\n            `${(node.data.type as any).name}`\n          )\n        );\n      }\n\n      state.nodes[id] = {\n        ...node,\n        data: {\n          ...node.data,\n          parent: parentId,\n        },\n      };\n\n      if (node.data.nodes.length > 0) {\n        delete state.nodes[id].data.props.children;\n        node.data.nodes.forEach((childNodeId) =>\n          iterateChildren(childNodeId, node.id)\n        );\n      }\n\n      Object.values(node.data.linkedNodes).forEach((linkedNodeId) =>\n        iterateChildren(linkedNodeId, node.id)\n      );\n    };\n\n    iterateChildren(tree.rootNodeId, parentId);\n\n    if (!parentId && tree.rootNodeId === ROOT_NODE) {\n      return;\n    }\n\n    const parent = getParentAndValidate(parentId);\n\n    if (addNodeType.type === 'child') {\n      const index = addNodeType.index;\n\n      if (index != null) {\n        parent.data.nodes.splice(index, 0, tree.rootNodeId);\n      } else {\n        parent.data.nodes.push(tree.rootNodeId);\n      }\n\n      return;\n    }\n\n    parent.data.linkedNodes[addNodeType.id] = tree.rootNodeId;\n  };\n\n  const getParentAndValidate = (parentId: NodeId): Node => {\n    invariant(parentId, ERROR_NOPARENT);\n    const parent = state.nodes[parentId];\n    invariant(parent, ERROR_INVALID_NODEID);\n    return parent;\n  };\n\n  const deleteNode = (id: NodeId) => {\n    const targetNode = state.nodes[id],\n      parentNode = state.nodes[targetNode.data.parent];\n\n    if (targetNode.data.nodes) {\n      // we deep clone here because otherwise immer will mutate the node\n      // object as we remove nodes\n      [...targetNode.data.nodes].forEach((childId) => deleteNode(childId));\n    }\n\n    if (targetNode.data.linkedNodes) {\n      Object.values(targetNode.data.linkedNodes).map((linkedNodeId) =>\n        deleteNode(linkedNodeId)\n      );\n    }\n\n    const isChildNode = parentNode.data.nodes.includes(id);\n\n    if (isChildNode) {\n      const parentChildren = parentNode.data.nodes;\n      parentChildren.splice(parentChildren.indexOf(id), 1);\n    } else {\n      const linkedId = Object.keys(parentNode.data.linkedNodes).find(\n        (id) => parentNode.data.linkedNodes[id] === id\n      );\n      if (linkedId) {\n        delete parentNode.data.linkedNodes[linkedId];\n      }\n    }\n\n    removeNodeFromEvents(state, id);\n    delete state.nodes[id];\n  };\n\n  return {\n    /**\n     * @private\n     * Add a new linked Node to the editor.\n     * Only used internally by the <Element /> component\n     *\n     * @param tree\n     * @param parentId\n     * @param id\n     */\n    addLinkedNodeFromTree(tree: NodeTree, parentId: NodeId, id: string) {\n      const parent = getParentAndValidate(parentId);\n\n      const existingLinkedNode = parent.data.linkedNodes[id];\n\n      if (existingLinkedNode) {\n        deleteNode(existingLinkedNode);\n      }\n\n      addNodeTreeToParent(tree, parentId, { type: 'linked', id });\n    },\n\n    /**\n     * Add a new Node to the editor.\n     *\n     * @param nodeToAdd\n     * @param parentId\n     * @param index\n     */\n    add(nodeToAdd: Node | Node[], parentId?: NodeId, index?: number) {\n      // TODO: Deprecate adding array of Nodes to keep implementation simpler\n      let nodes = [nodeToAdd];\n      if (Array.isArray(nodeToAdd)) {\n        deprecationWarning('actions.add(node: Node[])', {\n          suggest: 'actions.add(node: Node)',\n        });\n        nodes = nodeToAdd;\n      }\n      nodes.forEach((node: Node) => {\n        addNodeTreeToParent(\n          {\n            nodes: {\n              [node.id]: node,\n            },\n            rootNodeId: node.id,\n          },\n          parentId,\n          { type: 'child', index }\n        );\n      });\n    },\n\n    /**\n     * Add a NodeTree to the editor\n     *\n     * @param tree\n     * @param parentId\n     * @param index\n     */\n    addNodeTree(tree: NodeTree, parentId?: NodeId, index?: number) {\n      addNodeTreeToParent(tree, parentId, { type: 'child', index });\n    },\n\n    /**\n     * Delete a Node\n     * @param id\n     */\n    delete(selector: NodeSelector<NodeSelectorType.Id>) {\n      const targets = getNodesFromSelector(state.nodes, selector, {\n        existOnly: true,\n        idOnly: true,\n      });\n\n      targets.forEach(({ node }) => {\n        invariant(\n          !query.node(node.id).isTopLevelNode(),\n          ERROR_DELETE_TOP_LEVEL_NODE\n        );\n        deleteNode(node.id);\n      });\n    },\n\n    deserialize(input: SerializedNodes | string) {\n      const dehydratedNodes =\n        typeof input == 'string' ? JSON.parse(input) : input;\n\n      const nodePairs = Object.keys(dehydratedNodes).map((id) => {\n        let nodeId = id;\n\n        if (id === DEPRECATED_ROOT_NODE) {\n          nodeId = ROOT_NODE;\n        }\n\n        return [\n          nodeId,\n          query\n            .parseSerializedNode(dehydratedNodes[id])\n            .toNode((node) => (node.id = nodeId)),\n        ];\n      });\n\n      this.replaceNodes(fromEntries(nodePairs));\n    },\n\n    /**\n     * Move a target Node to a new Parent at a given index\n     * @param targetId\n     * @param newParentId\n     * @param index\n     */\n    move(selector: NodeSelector, newParentId: NodeId, index: number) {\n      const targets = getNodesFromSelector(state.nodes, selector, {\n        existOnly: true,\n      });\n\n      const newParent = state.nodes[newParentId];\n\n      const nodesArrToCleanup = new Set<string[]>();\n\n      targets.forEach(({ node: targetNode }, i) => {\n        const targetId = targetNode.id;\n        const currentParentId = targetNode.data.parent;\n\n        query.node(newParentId).isDroppable([targetId], (err) => {\n          throw new Error(err);\n        });\n\n        // modify node props\n        state.options.onBeforeMoveEnd(\n          targetNode,\n          newParent,\n          state.nodes[currentParentId]\n        );\n\n        const currentParent = state.nodes[currentParentId];\n        const currentParentNodes = currentParent.data.nodes;\n\n        nodesArrToCleanup.add(currentParentNodes);\n\n        const oldIndex = currentParentNodes.indexOf(targetId);\n        currentParentNodes[oldIndex] = '$$'; // mark for deletion\n\n        newParent.data.nodes.splice(index + i, 0, targetId);\n\n        state.nodes[targetId].data.parent = newParentId;\n      });\n\n      nodesArrToCleanup.forEach((nodes) => {\n        const length = nodes.length;\n\n        [...nodes].reverse().forEach((value, index) => {\n          if (value !== '$$') {\n            return;\n          }\n\n          nodes.splice(length - 1 - index, 1);\n        });\n      });\n    },\n\n    replaceNodes(nodes: Nodes) {\n      this.clearEvents();\n      state.nodes = nodes;\n    },\n\n    clearEvents() {\n      this.setNodeEvent('selected', null);\n      this.setNodeEvent('hovered', null);\n      this.setNodeEvent('dragged', null);\n      this.setIndicator(null);\n    },\n\n    /**\n     * Resets all the editor state.\n     */\n    reset() {\n      this.clearEvents();\n      this.replaceNodes({});\n    },\n\n    /**\n     * Set editor options via a callback function\n     *\n     * @param cb: function used to set the options.\n     */\n    setOptions(cb: (options: Partial<Options>) => void) {\n      cb(state.options);\n    },\n\n    setNodeEvent(\n      eventType: NodeEventTypes,\n      nodeIdSelector: NodeSelector<NodeSelectorType.Id>\n    ) {\n      state.events[eventType].forEach((id) => {\n        if (state.nodes[id]) {\n          state.nodes[id].events[eventType] = false;\n        }\n      });\n\n      state.events[eventType] = new Set();\n\n      if (!nodeIdSelector) {\n        return;\n      }\n\n      const targets = getNodesFromSelector(state.nodes, nodeIdSelector, {\n        idOnly: true,\n        existOnly: true,\n      });\n\n      const nodeIds: Set<NodeId> = new Set(targets.map(({ node }) => node.id));\n      nodeIds.forEach((id) => {\n        state.nodes[id].events[eventType] = true;\n      });\n      state.events[eventType] = nodeIds;\n    },\n\n    /**\n     * Set custom values to a Node\n     * @param id\n     * @param cb\n     */\n    setCustom<T extends NodeId>(\n      selector: NodeSelector<NodeSelectorType.Id>,\n      cb: (data: EditorState['nodes'][T]['data']['custom']) => void\n    ) {\n      const targets = getNodesFromSelector(state.nodes, selector, {\n        idOnly: true,\n        existOnly: true,\n      });\n\n      targets.forEach(({ node }) => cb(state.nodes[node.id].data.custom));\n    },\n\n    /**\n     * Given a `id`, it will set the `dom` porperty of that node.\n     *\n     * @param id of the node we want to set\n     * @param dom\n     */\n    setDOM(id: NodeId, dom: HTMLElement) {\n      if (!state.nodes[id]) {\n        return;\n      }\n\n      state.nodes[id].dom = dom;\n    },\n\n    setIndicator(indicator: Indicator | null) {\n      if (\n        indicator &&\n        (!indicator.placement.parent.dom ||\n          (indicator.placement.currentNode &&\n            !indicator.placement.currentNode.dom))\n      )\n        return;\n      state.indicator = indicator;\n    },\n\n    /**\n     * Set snap guides during drag operations\n     * @param guides - array of snap guide lines to display\n     */\n    setSnapGuides(guides: EditorState['snapGuides']) {\n      state.snapGuides = guides || [];\n    },\n\n    /**\n     * Hide a Node\n     * @param id\n     * @param bool\n     */\n    setHidden(id: NodeId, bool: boolean) {\n      state.nodes[id].data.hidden = bool;\n    },\n\n    /**\n     * Update the props of a Node\n     * @param id\n     * @param cb\n     */\n    setProp(\n      selector: NodeSelector<NodeSelectorType.Id>,\n      cb: (props: any) => void\n    ) {\n      const targets = getNodesFromSelector(state.nodes, selector, {\n        idOnly: true,\n        existOnly: true,\n      });\n\n      targets.forEach(({ node }) => cb(state.nodes[node.id].data.props));\n    },\n\n    selectNode(nodeIdSelector?: NodeSelector<NodeSelectorType.Id>) {\n      if (nodeIdSelector) {\n        const targets = getNodesFromSelector(state.nodes, nodeIdSelector, {\n          idOnly: true,\n          existOnly: true,\n        });\n\n        this.setNodeEvent(\n          'selected',\n          targets.map(({ node }) => node.id)\n        );\n      } else {\n        this.setNodeEvent('selected', null);\n      }\n\n      this.setNodeEvent('hovered', null);\n    },\n  };\n};\n\nexport const ActionMethods = (\n  state: EditorState,\n  query: QueryCallbacksFor<typeof QueryMethods>\n) => {\n  return {\n    ...Methods(state, query),\n    // Note: Beware: advanced method! You most likely don't need to use this\n    // TODO: fix parameter types and cleanup the method\n    setState(\n      cb: (\n        state: EditorState,\n        actions: Delete<CallbacksFor<typeof Methods>, 'history'>\n      ) => void\n    ) {\n      const { history, ...actions } = this;\n\n      // We pass the other actions as the second parameter, so that devs could still make use of the predefined actions\n      cb(state, actions);\n    },\n  };\n};\n","import { EditorState, NodeId } from '../interfaces';\n\nexport const removeNodeFromEvents = (state: EditorState, nodeId: NodeId) =>\n  Object.keys(state.events).forEach((key) => {\n    const eventSet = state.events[key];\n    if (eventSet && eventSet.has && eventSet.has(nodeId)) {\n      state.events[key] = new Set(\n        Array.from(eventSet).filter((id) => nodeId !== id)\n      );\n    }\n  });\n","import { ERROR_NOT_IN_RESOLVER } from '@craftjs/utils';\nimport React from 'react';\nimport invariant from 'tiny-invariant';\n\nimport { Resolver } from '../interfaces';\n\ntype ReversedResolver = Map<React.ComponentType | string, string>;\n\ntype CachedResolverData = {\n  resolver: Resolver;\n  reversed: ReversedResolver;\n};\n\nlet CACHED_RESOLVER_DATA: CachedResolverData | null = null;\n\nconst getReversedResolver = (resolver: Resolver): ReversedResolver => {\n  if (CACHED_RESOLVER_DATA && CACHED_RESOLVER_DATA.resolver === resolver) {\n    return CACHED_RESOLVER_DATA.reversed;\n  }\n\n  CACHED_RESOLVER_DATA = {\n    resolver,\n    reversed: new Map(),\n  };\n\n  for (const [name, comp] of Object.entries(resolver)) {\n    CACHED_RESOLVER_DATA.reversed.set(comp, name);\n  }\n\n  return CACHED_RESOLVER_DATA.reversed;\n};\n\nconst getComponentName = (component: React.ElementType): string | undefined => {\n  return (component as any).name || (component as any).displayName;\n};\n\nconst searchComponentInResolver = (\n  resolver: Resolver,\n  comp: React.ElementType\n): string | null => {\n  const name = getReversedResolver(resolver).get(comp);\n  return name !== undefined ? name : null;\n};\n\nexport const resolveComponent = (\n  resolver: Resolver,\n  comp: React.ElementType | string\n): string => {\n  if (typeof comp === 'string') {\n    return comp;\n  }\n\n  const resolvedName = searchComponentInResolver(resolver, comp);\n\n  invariant(\n    resolvedName,\n    ERROR_NOT_IN_RESOLVER.replace('%node_type%', getComponentName(comp))\n  );\n\n  return resolvedName;\n};\n","import React, { Children } from 'react';\n\nimport { resolveComponent } from './resolveComponent';\n\nimport { NodeData, ReducedComp, SerializedNode } from '../interfaces';\nimport { Resolver } from '../interfaces';\n\nconst reduceType = (type: React.ElementType | string, resolver: Resolver) => {\n  if (typeof type === 'string') {\n    return type;\n  }\n  return { resolvedName: resolveComponent(resolver, type) };\n};\n\nexport const serializeComp = (\n  data: Pick<NodeData, 'type' | 'isCanvas' | 'props'>,\n  resolver: Resolver\n): ReducedComp => {\n  let { type, isCanvas, props } = data;\n  props = Object.keys(props).reduce((result: Record<string, any>, key) => {\n    const prop = props[key];\n\n    if (prop === undefined || prop === null || typeof prop === 'function') {\n      return result;\n    }\n\n    if (key === 'children' && typeof prop !== 'string') {\n      result[key] = Children.map(prop, (child) => {\n        if (typeof child === 'string') {\n          return child;\n        }\n        return serializeComp(child, resolver);\n      });\n    } else if (typeof prop.type === 'function') {\n      result[key] = serializeComp(prop, resolver);\n    } else {\n      result[key] = prop;\n    }\n    return result;\n  }, {});\n\n  return {\n    type: reduceType(type, resolver),\n    isCanvas: !!isCanvas,\n    props,\n  };\n};\n\nexport const serializeNode = (\n  data: Omit<NodeData, 'event'>,\n  resolver: Resolver\n): SerializedNode => {\n  const { type, props, isCanvas, name, ...nodeData } = data;\n\n  const reducedComp = serializeComp({ type, isCanvas, props }, resolver);\n\n  return {\n    ...reducedComp,\n    ...nodeData,\n  };\n};\n","import {\n  deprecationWarning,\n  ERROR_CANNOT_DRAG,\n  ERROR_DUPLICATE_NODEID,\n  ERROR_INVALID_NODE_ID,\n  ERROR_MOVE_INCOMING_PARENT,\n  ERROR_MOVE_NONCANVAS_CHILD,\n  ERROR_MOVE_OUTGOING_PARENT,\n  ERROR_MOVE_TO_DESCENDANT,\n  ERROR_MOVE_TO_NONCANVAS_PARENT,\n  ERROR_MOVE_TOP_LEVEL_NODE,\n  ERROR_MOVE_CANNOT_DROP,\n  ROOT_NODE,\n} from '@craftjs/utils';\nimport invariant from 'tiny-invariant';\n\nimport { EditorState, NodeId, NodeSelector } from '../interfaces';\nimport { getNodesFromSelector } from '../utils/getNodesFromSelector';\nimport { serializeNode } from '../utils/serializeNode';\n\nexport function NodeHelpers(state: EditorState, id: NodeId) {\n  invariant(typeof id == 'string', ERROR_INVALID_NODE_ID);\n\n  const node = state.nodes[id];\n\n  const nodeHelpers = (id) => NodeHelpers(state, id);\n\n  return {\n    isCanvas() {\n      return !!node.data.isCanvas;\n    },\n    isRoot() {\n      return node.id === ROOT_NODE;\n    },\n    isLinkedNode() {\n      return (\n        node.data.parent &&\n        nodeHelpers(node.data.parent).linkedNodes().includes(node.id)\n      );\n    },\n    isTopLevelNode() {\n      return this.isRoot() || this.isLinkedNode();\n    },\n    isDeletable() {\n      return !this.isTopLevelNode();\n    },\n    isParentOfTopLevelNodes: () =>\n      node.data.linkedNodes && Object.keys(node.data.linkedNodes).length > 0,\n    isParentOfTopLevelCanvas() {\n      deprecationWarning('query.node(id).isParentOfTopLevelCanvas', {\n        suggest: 'query.node(id).isParentOfTopLevelNodes',\n      });\n      return this.isParentOfTopLevelNodes();\n    },\n    isSelected() {\n      return state.events.selected.has(id);\n    },\n    isHovered() {\n      return state.events.hovered.has(id);\n    },\n    isDragged() {\n      return state.events.dragged.has(id);\n    },\n    get() {\n      return node;\n    },\n    ancestors(deep = false): NodeId[] {\n      function appendParentNode(\n        id: NodeId,\n        ancestors: NodeId[] = [],\n        depth: number = 0\n      ) {\n        const node = state.nodes[id];\n        if (!node) {\n          return ancestors;\n        }\n\n        ancestors.push(id);\n\n        if (!node.data.parent) {\n          return ancestors;\n        }\n\n        if (deep || (!deep && depth === 0)) {\n          ancestors = appendParentNode(node.data.parent, ancestors, depth + 1);\n        }\n        return ancestors;\n      }\n      return appendParentNode(node.data.parent);\n    },\n    descendants(\n      deep = false,\n      includeOnly?: 'linkedNodes' | 'childNodes'\n    ): NodeId[] {\n      function appendChildNode(\n        id: NodeId,\n        descendants: NodeId[] = [],\n        depth: number = 0\n      ) {\n        if (deep || (!deep && depth === 0)) {\n          const node = state.nodes[id];\n\n          if (!node) {\n            return descendants;\n          }\n\n          if (includeOnly !== 'childNodes') {\n            // Include linkedNodes if any\n            const linkedNodes = nodeHelpers(id).linkedNodes();\n\n            linkedNodes.forEach((nodeId) => {\n              descendants.push(nodeId);\n              descendants = appendChildNode(nodeId, descendants, depth + 1);\n            });\n          }\n\n          if (includeOnly !== 'linkedNodes') {\n            const childNodes = nodeHelpers(id).childNodes();\n\n            childNodes.forEach((nodeId) => {\n              descendants.push(nodeId);\n              descendants = appendChildNode(nodeId, descendants, depth + 1);\n            });\n          }\n\n          return descendants;\n        }\n        return descendants;\n      }\n      return appendChildNode(id);\n    },\n    linkedNodes() {\n      return Object.values(node.data.linkedNodes || {});\n    },\n    childNodes() {\n      return node.data.nodes || [];\n    },\n    isDraggable(onError?: (err: string) => void) {\n      try {\n        const targetNode = node;\n        invariant(!this.isTopLevelNode(), ERROR_MOVE_TOP_LEVEL_NODE);\n        invariant(\n          NodeHelpers(state, targetNode.data.parent).isCanvas(),\n          ERROR_MOVE_NONCANVAS_CHILD\n        );\n        invariant(\n          targetNode.rules.canDrag(targetNode, nodeHelpers),\n          ERROR_CANNOT_DRAG\n        );\n        return true;\n      } catch (err) {\n        if (onError) {\n          onError(err);\n        }\n        return false;\n      }\n    },\n    isDroppable(selector: NodeSelector, onError?: (err: string) => void) {\n      const targets = getNodesFromSelector(state.nodes, selector);\n\n      const newParentNode = node;\n\n      try {\n        invariant(this.isCanvas(), ERROR_MOVE_TO_NONCANVAS_PARENT);\n        invariant(\n          newParentNode.rules.canMoveIn(\n            targets.map((selector) => selector.node),\n            newParentNode,\n            nodeHelpers\n          ),\n          ERROR_MOVE_INCOMING_PARENT\n        );\n\n        const parentNodes = {};\n\n        targets.forEach(({ node: targetNode, exists }) => {\n          invariant(\n            targetNode.rules.canDrop(newParentNode, targetNode, nodeHelpers),\n            ERROR_MOVE_CANNOT_DROP\n          );\n\n          // Ignore other checking if the Node is new\n          if (!exists) {\n            return;\n          }\n\n          invariant(\n            !nodeHelpers(targetNode.id).isTopLevelNode(),\n            ERROR_MOVE_TOP_LEVEL_NODE\n          );\n\n          const targetDeepNodes = nodeHelpers(targetNode.id).descendants(true);\n\n          invariant(\n            !targetDeepNodes.includes(newParentNode.id) &&\n              newParentNode.id !== targetNode.id,\n            ERROR_MOVE_TO_DESCENDANT\n          );\n\n          const currentParentNode =\n            targetNode.data.parent && state.nodes[targetNode.data.parent];\n\n          invariant(\n            currentParentNode.data.isCanvas,\n            ERROR_MOVE_NONCANVAS_CHILD\n          );\n\n          invariant(\n            currentParentNode ||\n              (!currentParentNode && !state.nodes[targetNode.id]),\n            ERROR_DUPLICATE_NODEID\n          );\n\n          if (currentParentNode.id !== newParentNode.id) {\n            if (!parentNodes[currentParentNode.id]) {\n              parentNodes[currentParentNode.id] = [];\n            }\n\n            parentNodes[currentParentNode.id].push(targetNode);\n          }\n        });\n\n        Object.keys(parentNodes).forEach((parentNodeId) => {\n          const childNodes = parentNodes[parentNodeId];\n          const parentNode = state.nodes[parentNodeId];\n\n          invariant(\n            parentNode.rules.canMoveOut(childNodes, parentNode, nodeHelpers),\n            ERROR_MOVE_OUTGOING_PARENT\n          );\n        });\n\n        return true;\n      } catch (err) {\n        if (onError) {\n          onError(err);\n        }\n        return false;\n      }\n    },\n    toSerializedNode() {\n      return serializeNode(node.data, state.options.resolver);\n    },\n    toNodeTree(includeOnly?: 'linkedNodes' | 'childNodes') {\n      const nodes = [id, ...this.descendants(true, includeOnly)].reduce(\n        (accum, descendantId) => {\n          accum[descendantId] = nodeHelpers(descendantId).get();\n          return accum;\n        },\n        {}\n      );\n\n      return {\n        rootNodeId: id,\n        nodes,\n      };\n    },\n\n    /**\n     Deprecated NodeHelpers\n     **/\n\n    decendants(deep = false) {\n      deprecationWarning('query.node(id).decendants', {\n        suggest: 'query.node(id).descendants',\n      });\n      return this.descendants(deep);\n    },\n    isTopLevelCanvas() {\n      return !this.isRoot() && !node.data.parent;\n    },\n  };\n}\n","import { Node, NodeInfo, DropPosition } from '../interfaces';\n\nexport default function findPosition(\n  parent: Node,\n  dims: NodeInfo[],\n  posX: number,\n  posY: number\n) {\n  let result: DropPosition = {\n    parent,\n    index: 0,\n    where: 'before',\n  };\n\n  let leftLimit = 0,\n    xLimit = 0,\n    dimRight = 0,\n    yLimit = 0,\n    xCenter = 0,\n    yCenter = 0,\n    dimDown = 0;\n\n  // Each dim is: Top, Left, Height, Width\n  for (let i = 0, len = dims.length; i < len; i++) {\n    const dim = dims[i];\n\n    // Right position of the element. Left + Width\n    dimRight = dim.left + dim.outerWidth;\n    // Bottom position of the element. Top + Height\n    dimDown = dim.top + dim.outerHeight;\n    // X center position of the element. Left + (Width / 2)\n    xCenter = dim.left + dim.outerWidth / 2;\n    // Y center position of the element. Top + (Height / 2)\n    yCenter = dim.top + dim.outerHeight / 2;\n    // Skip if over the limits\n    if (\n      (xLimit && dim.left > xLimit) ||\n      (yLimit && yCenter >= yLimit) || // >= avoid issue with clearfixes\n      (leftLimit && dimRight < leftLimit)\n    )\n      continue;\n\n    result.index = i;\n    // If it's not in flow (like 'float' element)\n    if (!dim.inFlow) {\n      if (posY < dimDown) yLimit = dimDown;\n      //If x lefter than center\n      if (posX < xCenter) {\n        xLimit = xCenter;\n        result.where = 'before';\n      } else {\n        leftLimit = xCenter;\n        result.where = 'after';\n      }\n    } else {\n      // If y upper than center\n      if (posY < yCenter) {\n        result.where = 'before';\n        break;\n      } else result.where = 'after'; // After last element\n    }\n  }\n\n  return result;\n}\n","import { getRandomId as getRandomNodeId } from '@craftjs/utils';\nimport React from 'react';\n\nimport { Node, FreshNode, UserComponentConfig } from '../interfaces';\nimport {\n  defaultElementProps,\n  Element,\n  Canvas,\n  elementPropToNodeData,\n  deprecateCanvasComponent,\n} from '../nodes';\nimport { NodeProvider } from '../nodes/NodeContext';\n\nconst getNodeTypeName = (type: string | { name: string }) =>\n  typeof type == 'string' ? type : type.name;\n\nexport function createNode(\n  newNode: FreshNode,\n  normalize?: (node: Node) => void\n) {\n  let actualType = newNode.data.type as any;\n  let id = newNode.id || getRandomNodeId();\n\n  const node: Node = {\n    id,\n    _hydrationTimestamp: Date.now(),\n    data: {\n      type: actualType,\n      name: getNodeTypeName(actualType),\n      displayName: getNodeTypeName(actualType),\n      props: {},\n      custom: {},\n      parent: null,\n      isCanvas: false,\n      hidden: false,\n      nodes: [],\n      linkedNodes: {},\n      ...newNode.data,\n    },\n    info: {},\n    related: {},\n    events: {\n      selected: false,\n      dragged: false,\n      hovered: false,\n    },\n    rules: {\n      canDrag: () => true,\n      canDrop: () => true,\n      canMoveIn: () => true,\n      canMoveOut: () => true,\n    },\n    dom: null,\n  };\n\n  // @ts-ignore\n  if (node.data.type === Element || node.data.type === Canvas) {\n    const mergedProps = {\n      ...defaultElementProps,\n      ...node.data.props,\n    };\n\n    node.data.props = Object.keys(node.data.props).reduce((props, key) => {\n      if (Object.keys(defaultElementProps).includes(key)) {\n        // If a <Element /> specific props is found (ie: \"is\", \"canvas\")\n        // Replace the node.data with the value specified in the prop\n        node.data[elementPropToNodeData[key] || key] = mergedProps[key];\n      } else {\n        // Otherwise include the props in the node as usual\n        props[key] = node.data.props[key];\n      }\n\n      return props;\n    }, {});\n\n    actualType = node.data.type;\n    node.data.name = getNodeTypeName(actualType);\n    node.data.displayName = getNodeTypeName(actualType);\n\n    const usingDeprecatedCanvas = node.data.type === Canvas;\n    if (usingDeprecatedCanvas) {\n      node.data.isCanvas = true;\n      deprecateCanvasComponent();\n    }\n  }\n\n  if (normalize) {\n    normalize(node);\n  }\n\n  // TODO: use UserComponentConfig type\n  const userComponentConfig = actualType.craft as UserComponentConfig<any>;\n\n  if (userComponentConfig) {\n    node.data.displayName =\n      userComponentConfig.displayName ||\n      userComponentConfig.name ||\n      node.data.displayName;\n\n    node.data.props = {\n      ...(userComponentConfig.props || userComponentConfig.defaultProps || {}),\n      ...node.data.props,\n    };\n\n    node.data.custom = {\n      ...(userComponentConfig.custom || {}),\n      ...node.data.custom,\n    };\n\n    if (\n      userComponentConfig.isCanvas !== undefined &&\n      userComponentConfig.isCanvas !== null\n    ) {\n      node.data.isCanvas = userComponentConfig.isCanvas;\n    }\n\n    if (userComponentConfig.rules) {\n      Object.keys(userComponentConfig.rules).forEach((key) => {\n        if (['canDrag', 'canDrop', 'canMoveIn', 'canMoveOut'].includes(key)) {\n          node.rules[key] = userComponentConfig.rules[key];\n        }\n      });\n    }\n\n    if (userComponentConfig.related) {\n      const relatedNodeContext = {\n        id: node.id,\n        related: true,\n      };\n\n      Object.keys(userComponentConfig.related).forEach((comp) => {\n        node.related[comp] = (props) =>\n          React.createElement(\n            NodeProvider,\n            relatedNodeContext,\n            React.createElement(userComponentConfig.related[comp], props)\n          );\n      });\n    }\n\n    if (userComponentConfig.info) {\n      node.info = userComponentConfig.info;\n    }\n  }\n\n  return node;\n}\n","import { ERROR_DESERIALIZE_COMPONENT_NOT_IN_RESOLVER } from '@craftjs/utils';\nimport React from 'react';\nimport invariant from 'tiny-invariant';\n\nimport { resolveComponent } from './resolveComponent';\n\nimport {\n  NodeData,\n  SerializedNode,\n  ReducedComp,\n  ReduceCompType,\n} from '../interfaces';\nimport { Resolver } from '../interfaces';\nimport { Canvas } from '../nodes/Canvas';\n\ntype DeserialisedType = React.JSX.Element & { name: string };\n\nconst restoreType = (type: ReduceCompType, resolver: Resolver) =>\n  typeof type === 'object' && type.resolvedName\n    ? type.resolvedName === 'Canvas'\n      ? Canvas\n      : resolver[type.resolvedName]\n    : typeof type === 'string'\n    ? type\n    : null;\n\nexport const deserializeComp = (\n  data: ReducedComp,\n  resolver: Resolver,\n  index?: number\n): DeserialisedType | void => {\n  let { type, props } = data;\n\n  const main = restoreType(type, resolver);\n\n  if (!main) {\n    return;\n  }\n\n  props = Object.keys(props).reduce((result: Record<string, any>, key) => {\n    const prop = props[key];\n    if (prop === null || prop === undefined) {\n      result[key] = null;\n    } else if (typeof prop === 'object' && prop.resolvedName) {\n      result[key] = deserializeComp(prop, resolver);\n    } else if (key === 'children' && Array.isArray(prop)) {\n      result[key] = prop.map((child) => {\n        if (typeof child === 'string') {\n          return child;\n        }\n        return deserializeComp(child, resolver);\n      });\n    } else {\n      result[key] = prop;\n    }\n    return result;\n  }, {});\n\n  if (index) {\n    props.key = index;\n  }\n\n  const jsx = {\n    ...React.createElement(main, {\n      ...props,\n    }),\n  };\n\n  return {\n    ...jsx,\n    name: resolveComponent(resolver, jsx.type),\n  };\n};\n\nexport const deserializeNode = (\n  data: SerializedNode,\n  resolver: Resolver\n): Omit<NodeData, 'event'> => {\n  const { type: Comp, props: Props, ...nodeData } = data;\n\n  const isCompAnHtmlElement = Comp !== undefined && typeof Comp === 'string';\n  const isCompAUserComponent =\n    Comp !== undefined &&\n    (Comp as { resolvedName?: string }).resolvedName !== undefined;\n\n  invariant(\n    isCompAnHtmlElement || isCompAUserComponent,\n    ERROR_DESERIALIZE_COMPONENT_NOT_IN_RESOLVER.replace(\n      '%displayName%',\n      data.displayName\n    ).replace('%availableComponents%', Object.keys(resolver).join(', '))\n  );\n\n  const { type, name, props } = (deserializeComp(\n    data,\n    resolver\n  ) as unknown) as NodeData;\n\n  const { parent, custom, displayName, isCanvas, nodes, hidden } = nodeData;\n\n  const linkedNodes = nodeData.linkedNodes || nodeData._childCanvas;\n\n  return {\n    type,\n    name,\n    displayName: displayName || name,\n    props,\n    custom: custom || {},\n    isCanvas: !!isCanvas,\n    hidden: !!hidden,\n    parent,\n    linkedNodes: linkedNodes || {},\n    nodes: nodes || [],\n  };\n};\n","import { Node, NodeTree } from '../interfaces';\n\nconst mergeNodes = (rootNode: Node, childrenNodes: NodeTree[]) => {\n  if (childrenNodes.length < 1) {\n    return { [rootNode.id]: rootNode };\n  }\n  const nodes = childrenNodes.map(({ rootNodeId }) => rootNodeId);\n  const nodeWithChildren = { ...rootNode, data: { ...rootNode.data, nodes } };\n  const rootNodes = { [rootNode.id]: nodeWithChildren };\n  return childrenNodes.reduce((accum, tree) => {\n    const currentNode = tree.nodes[tree.rootNodeId];\n    return {\n      ...accum,\n      ...tree.nodes,\n      // set the parent id for the current node\n      [currentNode.id]: {\n        ...currentNode,\n        data: {\n          ...currentNode.data,\n          parent: rootNode.id,\n        },\n      },\n    };\n  }, rootNodes);\n};\n\nexport const mergeTrees = (\n  rootNode: Node,\n  childrenNodes: NodeTree[]\n): NodeTree => ({\n  rootNodeId: rootNode.id,\n  nodes: mergeNodes(rootNode, childrenNodes),\n});\n","import {\n  QueryCallbacksFor,\n  ERROR_NOT_IN_RESOLVER,\n  getDOMInfo,\n  deprecationWarning,\n  DEPRECATED_ROOT_NODE,\n  ROOT_NODE,\n} from '@craftjs/utils';\nimport React from 'react';\nimport invariant from 'tiny-invariant';\n\nimport { EventHelpers } from './EventHelpers';\nimport { NodeHelpers } from './NodeHelpers';\n\nimport findPosition from '../events/findPosition';\nimport {\n  NodeId,\n  EditorState,\n  Indicator,\n  Node,\n  Options,\n  NodeEventTypes,\n  NodeInfo,\n  NodeSelector,\n  NodeTree,\n  SerializedNodes,\n  SerializedNode,\n  FreshNode,\n} from '../interfaces';\nimport { createNode } from '../utils/createNode';\nimport { deserializeNode } from '../utils/deserializeNode';\nimport { fromEntries } from '../utils/fromEntries';\nimport { getNodesFromSelector } from '../utils/getNodesFromSelector';\nimport { mergeTrees } from '../utils/mergeTrees';\nimport { parseNodeFromJSX } from '../utils/parseNodeFromJSX';\nimport { resolveComponent } from '../utils/resolveComponent';\n\nexport function QueryMethods(state: EditorState) {\n  const options = state && state.options;\n\n  const _: () => QueryCallbacksFor<typeof QueryMethods> = () =>\n    QueryMethods(state) as any;\n\n  return {\n    /**\n     * Determine the best possible location to drop the source Node relative to the target Node\n     *\n     * TODO: replace with Positioner.computeIndicator();\n     */\n    getDropPlaceholder: (\n      source: NodeSelector,\n      target: NodeId,\n      pos: { x: number; y: number },\n      nodesToDOM: (node: Node) => HTMLElement = (node) =>\n        state.nodes[node.id].dom\n    ) => {\n      const targetNode = state.nodes[target],\n        isTargetCanvas = _().node(targetNode.id).isCanvas();\n\n      const targetParent = isTargetCanvas\n        ? targetNode\n        : state.nodes[targetNode.data.parent];\n\n      if (!targetParent) return;\n\n      const targetParentNodes = targetParent.data.nodes || [];\n\n      const dimensionsInContainer = targetParentNodes\n        ? targetParentNodes.reduce((result, id: NodeId) => {\n            const dom = nodesToDOM(state.nodes[id]);\n            if (dom) {\n              const info: NodeInfo = {\n                id,\n                ...getDOMInfo(dom),\n              };\n\n              result.push(info);\n            }\n            return result;\n          }, [] as NodeInfo[])\n        : [];\n\n      const dropAction = findPosition(\n        targetParent,\n        dimensionsInContainer,\n        pos.x,\n        pos.y\n      );\n      const currentNode =\n        targetParentNodes.length &&\n        state.nodes[targetParentNodes[dropAction.index]];\n\n      const output: Indicator = {\n        placement: {\n          ...dropAction,\n          currentNode,\n        },\n        error: null,\n      };\n\n      const sourceNodes = getNodesFromSelector(state.nodes, source);\n\n      sourceNodes.forEach(({ node, exists }) => {\n        // If source Node is already in the editor, check if it's draggable\n        if (exists) {\n          _()\n            .node(node.id)\n            .isDraggable((err) => (output.error = err));\n        }\n      });\n\n      // Check if source Node is droppable in target\n      _()\n        .node(targetParent.id)\n        .isDroppable(source, (err) => (output.error = err));\n\n      return output;\n    },\n\n    /**\n     * Get the current Editor options\n     */\n    getOptions(): Options {\n      return options;\n    },\n\n    getNodes() {\n      return state.nodes;\n    },\n\n    /**\n     * Helper methods to describe the specified Node\n     * @param id\n     */\n    node(id: NodeId) {\n      return NodeHelpers(state, id);\n    },\n\n    /**\n     * Returns all the `nodes` in a serialized format\n     */\n    getSerializedNodes(): SerializedNodes {\n      const nodePairs = Object.keys(state.nodes).map((id: NodeId) => [\n        id,\n        this.node(id).toSerializedNode(),\n      ]);\n      return fromEntries(nodePairs);\n    },\n\n    getEvent(eventType: NodeEventTypes) {\n      return EventHelpers(state, eventType);\n    },\n\n    /**\n     * Retrieve the JSON representation of the editor's Nodes\n     */\n    serialize(): string {\n      return JSON.stringify(this.getSerializedNodes());\n    },\n\n    parseReactElement: (reactElement: React.ReactElement<any>) => ({\n      toNodeTree(\n        normalize?: (node: Node, jsx: React.ReactElement<any>) => void\n      ): NodeTree {\n        let node = parseNodeFromJSX(reactElement, (node, jsx) => {\n          const name = resolveComponent(state.options.resolver, node.data.type);\n\n          node.data.displayName = node.data.displayName || name;\n          node.data.name = name;\n\n          if (normalize) {\n            normalize(node, jsx);\n          }\n        });\n\n        let childrenNodes: NodeTree[] = [];\n\n        if (reactElement.props && reactElement.props.children) {\n          childrenNodes = React.Children.toArray(\n            reactElement.props.children\n          ).reduce<NodeTree[]>((accum, child: any) => {\n            if (React.isValidElement(child)) {\n              accum.push(_().parseReactElement(child).toNodeTree(normalize));\n            }\n            return accum;\n          }, []);\n        }\n\n        return mergeTrees(node, childrenNodes);\n      },\n    }),\n\n    parseSerializedNode: (serializedNode: SerializedNode) => ({\n      toNode(normalize?: (node: Node) => void): Node {\n        const data = deserializeNode(serializedNode, state.options.resolver);\n        invariant(data.type, ERROR_NOT_IN_RESOLVER);\n\n        const id = typeof normalize === 'string' && normalize;\n\n        if (id) {\n          deprecationWarning(`query.parseSerializedNode(...).toNode(id)`, {\n            suggest: `query.parseSerializedNode(...).toNode(node => node.id = id)`,\n          });\n        }\n\n        return _()\n          .parseFreshNode({\n            ...(id ? { id } : {}),\n            data,\n          })\n          .toNode(!id && normalize);\n      },\n    }),\n\n    parseFreshNode: (node: FreshNode) => ({\n      toNode(normalize?: (node: Node) => void): Node {\n        return createNode(node, (node) => {\n          if (node.data.parent === DEPRECATED_ROOT_NODE) {\n            node.data.parent = ROOT_NODE;\n          }\n\n          const name = resolveComponent(state.options.resolver, node.data.type);\n          invariant(name !== null, ERROR_NOT_IN_RESOLVER);\n          node.data.displayName = node.data.displayName || name;\n          node.data.name = name;\n\n          if (normalize) {\n            normalize(node);\n          }\n        });\n      },\n    }),\n\n    createNode(reactElement: React.ReactElement, extras?: any) {\n      deprecationWarning(`query.createNode(${reactElement})`, {\n        suggest: `query.parseReactElement(${reactElement}).toNodeTree()`,\n      });\n\n      const tree = this.parseReactElement(reactElement).toNodeTree();\n\n      const node = tree.nodes[tree.rootNodeId];\n\n      if (!extras) {\n        return node;\n      }\n\n      if (extras.id) {\n        node.id = extras.id;\n      }\n\n      if (extras.data) {\n        node.data = {\n          ...node.data,\n          ...extras.data,\n        };\n      }\n\n      return node;\n    },\n\n    getState() {\n      return state;\n    },\n  };\n}\n","import { EditorState, NodeId, NodeEventTypes } from '../interfaces';\n\nexport function EventHelpers(state: EditorState, eventType: NodeEventTypes) {\n  const event = state.events[eventType];\n  return {\n    contains(id: NodeId) {\n      return event.has(id);\n    },\n    isEmpty() {\n      return this.all().length === 0;\n    },\n    first() {\n      const values = this.all();\n      return values[0];\n    },\n    last() {\n      const values = this.all();\n      return values[values.length - 1];\n    },\n    all() {\n      return Array.from(event);\n    },\n    size() {\n      return this.all().length;\n    },\n    at(i: number) {\n      return this.all()[i];\n    },\n    raw() {\n      return event;\n    },\n  };\n}\n","import React, { Fragment } from 'react';\n\nimport { createNode } from './createNode';\n\nimport { Node } from '../interfaces';\n\nexport function parseNodeFromJSX(\n  jsx: React.ReactElement<any> | string,\n  normalize?: (node: Node, jsx: React.ReactElement<any>) => void\n) {\n  let element = jsx as React.ReactElement<any>;\n\n  if (typeof element === 'string') {\n    element = React.createElement(Fragment, {}, element) as React.ReactElement<\n      any\n    >;\n  }\n\n  let actualType = element.type as any;\n\n  return createNode(\n    {\n      data: {\n        type: actualType,\n        props: { ...element.props },\n      },\n    },\n    (node) => {\n      if (normalize) {\n        normalize(node, element);\n      }\n    }\n  );\n}\n","import { DerivedEventHandlers, EventHandlers } from '@craftjs/utils';\n\nimport { EditorStore } from '../editor/store';\nimport { NodeId, NodeTree } from '../interfaces/nodes';\n\nexport interface CreateHandlerOptions {\n  onCreate: (nodeTree: NodeTree) => void;\n}\n\nexport class CoreEventHandlers<O = {}> extends EventHandlers<\n  { store: EditorStore; removeHoverOnMouseleave: boolean } & O\n> {\n  handlers() {\n    return {\n      connect: (el: HTMLElement, id: NodeId) => {},\n      select: (el: HTMLElement, id: NodeId) => {},\n      hover: (el: HTMLElement, id: NodeId) => {},\n      drag: (el: HTMLElement, id: NodeId) => {},\n      drop: (el: HTMLElement, id: NodeId) => {},\n      create: (\n        el: HTMLElement,\n        UserElement: React.ReactElement | (() => NodeTree | React.ReactElement),\n        options?: Partial<CreateHandlerOptions>\n      ) => {},\n    };\n  }\n}\n\nexport abstract class DerivedCoreEventHandlers<\n  O = {}\n> extends DerivedEventHandlers<CoreEventHandlers, O> {}\n","import { getDOMInfo } from '@craftjs/utils';\n\nimport { EditorStore } from '../editor/store';\nimport { NodeId, NodeInfo } from '../interfaces';\n\nexport interface SnapGuide {\n  type: 'horizontal' | 'vertical';\n  position: number; // y position for horizontal, x position for vertical\n  start: number; // start x for horizontal, start y for vertical\n  end: number; // end x for horizontal, end y for vertical\n}\n\nexport interface SnapResult {\n  guides: SnapGuide[];\n  snapX: number | null; // snapped x position (or null if no snap)\n  snapY: number | null; // snapped y position (or null if no snap)\n}\n\n/**\n * SnapGuideCalculator computes alignment guides during drag operations\n * Option A: Basic center-line snapping only\n */\nexport class SnapGuideCalculator {\n  static SNAP_THRESHOLD = 8; // pixels within which to snap\n\n  private siblingDimensions: NodeInfo[] = [];\n  private canvasBounds: DOMRect | null = null;\n\n  constructor(readonly store: EditorStore) {}\n\n  /**\n   * Initialize with sibling elements to snap against\n   */\n  setSiblings(parentId: NodeId, excludeIds: NodeId[]) {\n    const parentNode = this.store.query.node(parentId).get();\n    if (!parentNode) return;\n\n    // Get canvas/parent bounds\n    if (parentNode.dom) {\n      this.canvasBounds = parentNode.dom.getBoundingClientRect();\n    }\n\n    // Get all sibling dimensions except the ones being dragged\n    this.siblingDimensions = parentNode.data.nodes\n      .filter((id) => !excludeIds.includes(id))\n      .map((id) => {\n        const node = this.store.query.node(id).get();\n        if (!node || !node.dom) return null;\n        return {\n          id,\n          ...getDOMInfo(node.dom),\n        };\n      })\n      .filter(Boolean) as NodeInfo[];\n  }\n\n  /**\n   * Calculate snap guides based on current drag position\n   */\n  calculate(draggedRect: DOMRect): SnapResult {\n    const guides: SnapGuide[] = [];\n    let snapX: number | null = null;\n    let snapY: number | null = null;\n\n    const draggedCenterX = draggedRect.left + draggedRect.width / 2;\n    const draggedCenterY = draggedRect.top + draggedRect.height / 2;\n\n    // Check alignment with each sibling\n    for (const sibling of this.siblingDimensions) {\n      const siblingCenterX = sibling.left + sibling.width / 2;\n      const siblingCenterY = sibling.top + sibling.height / 2;\n\n      // Vertical center alignment (creates a vertical guide line)\n      const diffX = Math.abs(draggedCenterX - siblingCenterX);\n      if (diffX < SnapGuideCalculator.SNAP_THRESHOLD) {\n        snapX = siblingCenterX - draggedRect.width / 2;\n        guides.push({\n          type: 'vertical',\n          position: siblingCenterX,\n          start: Math.min(draggedRect.top, sibling.top),\n          end: Math.max(draggedRect.bottom, sibling.bottom),\n        });\n      }\n\n      // Horizontal center alignment (creates a horizontal guide line)\n      const diffY = Math.abs(draggedCenterY - siblingCenterY);\n      if (diffY < SnapGuideCalculator.SNAP_THRESHOLD) {\n        snapY = siblingCenterY - draggedRect.height / 2;\n        guides.push({\n          type: 'horizontal',\n          position: siblingCenterY,\n          start: Math.min(draggedRect.left, sibling.left),\n          end: Math.max(draggedRect.right, sibling.right),\n        });\n      }\n    }\n\n    // Also check alignment with canvas center\n    if (this.canvasBounds) {\n      const canvasCenterX =\n        this.canvasBounds.left + this.canvasBounds.width / 2;\n      const canvasCenterY =\n        this.canvasBounds.top + this.canvasBounds.height / 2;\n\n      const diffCanvasX = Math.abs(draggedCenterX - canvasCenterX);\n      if (diffCanvasX < SnapGuideCalculator.SNAP_THRESHOLD) {\n        snapX = canvasCenterX - draggedRect.width / 2;\n        guides.push({\n          type: 'vertical',\n          position: canvasCenterX,\n          start: this.canvasBounds.top,\n          end: this.canvasBounds.bottom,\n        });\n      }\n\n      const diffCanvasY = Math.abs(draggedCenterY - canvasCenterY);\n      if (diffCanvasY < SnapGuideCalculator.SNAP_THRESHOLD) {\n        snapY = canvasCenterY - draggedRect.height / 2;\n        guides.push({\n          type: 'horizontal',\n          position: canvasCenterY,\n          start: this.canvasBounds.left,\n          end: this.canvasBounds.right,\n        });\n      }\n    }\n\n    // Deduplicate guides (same position)\n    const uniqueGuides = this.deduplicateGuides(guides);\n\n    return {\n      guides: uniqueGuides,\n      snapX,\n      snapY,\n    };\n  }\n\n  private deduplicateGuides(guides: SnapGuide[]): SnapGuide[] {\n    const seen = new Map<string, SnapGuide>();\n\n    for (const guide of guides) {\n      const key = `${guide.type}-${Math.round(guide.position)}`;\n      const existing = seen.get(key);\n\n      if (!existing) {\n        seen.set(key, guide);\n      } else {\n        // Extend the existing guide\n        existing.start = Math.min(existing.start, guide.start);\n        existing.end = Math.max(existing.end, guide.end);\n      }\n    }\n\n    return Array.from(seen.values());\n  }\n\n  clear() {\n    this.siblingDimensions = [];\n    this.canvasBounds = null;\n  }\n}\n","import { getDOMInfo, ROOT_NODE } from '@craftjs/utils';\n\nimport findPosition from './findPosition';\nimport { SnapGuideCalculator } from './SnapGuideCalculator';\n\nimport { EditorStore } from '../editor/store';\nimport {\n  DragTarget,\n  DropPosition,\n  Indicator,\n  Node,\n  NodeId,\n  NodeInfo,\n  NodeSelectorWrapper,\n} from '../interfaces';\nimport { getNodesFromSelector } from '../utils/getNodesFromSelector';\n\n// Hack: to trigger dragend event immediate\n// Otherwise we would have to wait until the native animation is completed before we can actually drop an block\nconst documentDragoverEventHandler = (e: DragEvent) => {\n  e.preventDefault();\n};\n\n/**\n * Positioner is responsible for computing the drop Indicator during a sequence of drag-n-drop events\n */\nexport class Positioner {\n  static BORDER_OFFSET = 10;\n\n  // Current Node being hovered on\n  private currentDropTargetId: NodeId | null;\n  // Current closest Canvas Node relative to the currentDropTarget\n  private currentDropTargetCanvasAncestorId: NodeId | null;\n\n  private currentIndicator: Indicator | null = null;\n\n  private currentTargetId: NodeId | null;\n  private currentTargetChildDimensions: NodeInfo[] | null;\n\n  private dragError: string | null;\n  private draggedNodes: NodeSelectorWrapper[];\n\n  private onScrollListener: (e: Event) => void;\n\n  private snapGuideCalculator: SnapGuideCalculator;\n\n  constructor(readonly store: EditorStore, readonly dragTarget: DragTarget) {\n    this.currentDropTargetId = null;\n    this.currentDropTargetCanvasAncestorId = null;\n\n    this.currentTargetId = null;\n    this.currentTargetChildDimensions = null;\n\n    this.currentIndicator = null;\n\n    this.dragError = null;\n    this.draggedNodes = this.getDraggedNodes();\n\n    this.validateDraggedNodes();\n\n    this.snapGuideCalculator = new SnapGuideCalculator(store);\n\n    this.onScrollListener = this.onScroll.bind(this);\n    window.addEventListener('scroll', this.onScrollListener, true);\n    window.addEventListener('dragover', documentDragoverEventHandler, false);\n  }\n\n  cleanup() {\n    window.removeEventListener('scroll', this.onScrollListener, true);\n    window.removeEventListener('dragover', documentDragoverEventHandler, false);\n    this.snapGuideCalculator.clear();\n    this.store.actions.setSnapGuides([]);\n  }\n\n  private onScroll(e: Event) {\n    const scrollBody = e.target;\n    const rootNode = this.store.query.node(ROOT_NODE).get();\n\n    // Clear the currentTargetChildDimensions if the user has scrolled\n    // Because we will have to recompute new dimensions relative to the new scroll pos\n    const shouldClearChildDimensionsCache =\n      scrollBody instanceof Element &&\n      rootNode &&\n      rootNode.dom &&\n      scrollBody.contains(rootNode.dom);\n\n    if (!shouldClearChildDimensionsCache) {\n      return;\n    }\n\n    this.currentTargetChildDimensions = null;\n  }\n\n  private getDraggedNodes() {\n    if (this.dragTarget.type === 'new') {\n      return getNodesFromSelector(\n        this.store.query.getNodes(),\n        this.dragTarget.tree.nodes[this.dragTarget.tree.rootNodeId]\n      );\n    }\n\n    return getNodesFromSelector(\n      this.store.query.getNodes(),\n      this.dragTarget.nodes\n    );\n  }\n\n  // Check if the elements being dragged are allowed to be dragged\n  private validateDraggedNodes() {\n    // We don't need to check for dragTarget.type = \"new\" because those nodes are not yet in the state (ie: via the .create() connector)\n    if (this.dragTarget.type === 'new') {\n      return;\n    }\n\n    this.draggedNodes.forEach(({ node, exists }) => {\n      if (!exists) {\n        return;\n      }\n\n      this.store.query.node(node.id).isDraggable((err) => {\n        this.dragError = err;\n      });\n    });\n  }\n\n  private isNearBorders(\n    domInfo: ReturnType<typeof getDOMInfo>,\n    x: number,\n    y: number\n  ) {\n    const { top, bottom, left, right } = domInfo;\n\n    if (\n      top + Positioner.BORDER_OFFSET > y ||\n      bottom - Positioner.BORDER_OFFSET < y ||\n      left + Positioner.BORDER_OFFSET > x ||\n      right - Positioner.BORDER_OFFSET < x\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private isDiff(newPosition: DropPosition) {\n    if (\n      this.currentIndicator &&\n      this.currentIndicator.placement.parent.id === newPosition.parent.id &&\n      this.currentIndicator.placement.index === newPosition.index &&\n      this.currentIndicator.placement.where === newPosition.where\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get dimensions of every child Node in the specified parent Node\n   */\n  private getChildDimensions(newParentNode: Node) {\n    // Use previously computed child dimensions if newParentNode is the same as the previous one\n    const existingTargetChildDimensions = this.currentTargetChildDimensions;\n    if (\n      this.currentTargetId === newParentNode.id &&\n      existingTargetChildDimensions\n    ) {\n      return existingTargetChildDimensions;\n    }\n\n    return newParentNode.data.nodes.reduce((result, id: NodeId) => {\n      const dom = this.store.query.node(id).get().dom;\n\n      if (dom) {\n        result.push({\n          id,\n          ...getDOMInfo(dom),\n        });\n      }\n\n      return result;\n    }, [] as NodeInfo[]);\n  }\n\n  /**\n   * Get closest Canvas node relative to the dropTargetId\n   * Return dropTargetId if it itself is a Canvas node\n   *\n   * In most cases it will be the dropTarget itself or its immediate parent.\n   * We typically only need to traverse 2 levels or more if the dropTarget is a linked node\n   *\n   * TODO: We should probably have some special rules to handle linked nodes\n   */\n  private getCanvasAncestor(dropTargetId: NodeId) {\n    // If the dropTargetId is the same as the previous one\n    // Return the canvas ancestor node that we found previuously\n    if (\n      dropTargetId === this.currentDropTargetId &&\n      this.currentDropTargetCanvasAncestorId\n    ) {\n      const node = this.store.query\n        .node(this.currentDropTargetCanvasAncestorId)\n        .get();\n\n      if (node) {\n        return node;\n      }\n    }\n\n    const getCanvas = (nodeId: NodeId): Node => {\n      const node = this.store.query.node(nodeId).get();\n\n      if (node && node.data.isCanvas) {\n        return node;\n      }\n\n      if (!node.data.parent) {\n        return null;\n      }\n\n      return getCanvas(node.data.parent);\n    };\n\n    return getCanvas(dropTargetId);\n  }\n\n  /**\n   * Compute a new Indicator object based on the dropTarget and x,y coords\n   * Returns null if theres no change from the previous Indicator\n   */\n  computeIndicator(dropTargetId: NodeId, x: number, y: number): Indicator {\n    let newParentNode = this.getCanvasAncestor(dropTargetId);\n\n    if (!newParentNode) {\n      return;\n    }\n\n    this.currentDropTargetId = dropTargetId;\n    this.currentDropTargetCanvasAncestorId = newParentNode.id;\n\n    // Get parent if we're hovering at the border of the current node\n    if (\n      newParentNode.data.parent &&\n      this.isNearBorders(getDOMInfo(newParentNode.dom), x, y) &&\n      // Ignore if linked node because there's won't be an adjacent sibling anyway\n      !this.store.query.node(newParentNode.id).isLinkedNode()\n    ) {\n      newParentNode = this.store.query.node(newParentNode.data.parent).get();\n    }\n\n    if (!newParentNode) {\n      return;\n    }\n\n    this.currentTargetChildDimensions = this.getChildDimensions(newParentNode);\n    this.currentTargetId = newParentNode.id;\n\n    const position = findPosition(\n      newParentNode,\n      this.currentTargetChildDimensions,\n      x,\n      y\n    );\n\n    // Ignore if the position is similar as the previous one\n    if (!this.isDiff(position)) {\n      return;\n    }\n\n    let error = this.dragError;\n\n    // Last thing to check for is if the dragged nodes can be dropped in the target area\n    if (!error) {\n      this.store.query.node(newParentNode.id).isDroppable(\n        this.draggedNodes.map((sourceNode) => sourceNode.node),\n        (dropError) => {\n          error = dropError;\n        }\n      );\n    }\n\n    const currentNodeId = newParentNode.data.nodes[position.index];\n    const currentNode =\n      currentNodeId && this.store.query.node(currentNodeId).get();\n\n    this.currentIndicator = {\n      placement: {\n        ...position,\n        currentNode,\n      },\n      error,\n    };\n\n    // Compute snap guides for alignment visualization\n    // Get dragged node IDs to exclude from snap targets\n    const draggedNodeIds = this.draggedNodes.map((n) => n.node.id);\n\n    // Setup snap guide calculator with current parent's children\n    this.snapGuideCalculator.setSiblings(newParentNode.id, draggedNodeIds);\n\n    // Create a virtual rect around the mouse position (simulating dragged element)\n    // We use a small rect since we don't have the actual element dimensions during drag\n    const virtualDraggedRect = {\n      left: x - 50,\n      right: x + 50,\n      top: y - 25,\n      bottom: y + 25,\n      width: 100,\n      height: 50,\n    } as DOMRect;\n\n    const snapResult = this.snapGuideCalculator.calculate(virtualDraggedRect);\n    this.store.actions.setSnapGuides(snapResult.guides);\n\n    return this.currentIndicator;\n  }\n\n  getIndicator() {\n    return this.currentIndicator;\n  }\n}\n","// Works partially with Linux (except on Chrome)\n// We'll need an alternate way to create drag shadows\nexport const createShadow = (\n  e: DragEvent,\n  shadowsToCreate: HTMLElement[],\n  forceSingleShadow: boolean = false\n) => {\n  if (shadowsToCreate.length === 1 || forceSingleShadow) {\n    const { width, height } = shadowsToCreate[0].getBoundingClientRect();\n    const shadow = shadowsToCreate[0].cloneNode(true) as HTMLElement;\n\n    shadow.style.position = `absolute`;\n    shadow.style.left = `-100%`;\n    shadow.style.top = `-100%`;\n    shadow.style.width = `${width}px`;\n    shadow.style.height = `${height}px`;\n    shadow.style.pointerEvents = 'none';\n    shadow.classList.add('drag-shadow');\n\n    document.body.appendChild(shadow);\n    e.dataTransfer.setDragImage(shadow, 0, 0);\n\n    return shadow;\n  }\n\n  /**\n   * If there's supposed to be multiple drag shadows, we will create a single container div to store them\n   * That container will be used as the drag shadow for the current drag event\n   */\n  const container = document.createElement('div');\n  container.style.position = 'absolute';\n  container.style.left = '-100%';\n  container.style.top = `-100%`;\n  container.style.width = '100%';\n  container.style.height = '100%';\n  container.style.pointerEvents = 'none';\n  container.classList.add('drag-shadow-container');\n\n  shadowsToCreate.forEach((dom) => {\n    const { width, height, top, left } = dom.getBoundingClientRect();\n    const shadow = dom.cloneNode(true) as HTMLElement;\n\n    shadow.style.position = `absolute`;\n    shadow.style.left = `${left}px`;\n    shadow.style.top = `${top}px`;\n    shadow.style.width = `${width}px`;\n    shadow.style.height = `${height}px`;\n    shadow.classList.add('drag-shadow');\n\n    container.appendChild(shadow);\n  });\n\n  document.body.appendChild(container);\n  e.dataTransfer.setDragImage(container, e.clientX, e.clientY);\n\n  return container;\n};\n","import { isChromium, isLinux } from '@craftjs/utils';\nimport isFunction from 'lodash/isFunction';\nimport React from 'react';\n\nimport { CoreEventHandlers, CreateHandlerOptions } from './CoreEventHandlers';\nimport { Positioner } from './Positioner';\nimport { createShadow } from './createShadow';\n\nimport { Indicator, NodeId, DragTarget, NodeTree } from '../interfaces';\n\nexport type DefaultEventHandlersOptions = {\n  isMultiSelectEnabled: (e: MouseEvent) => boolean;\n  removeHoverOnMouseleave: boolean;\n};\n\n/**\n * Specifies Editor-wide event handlers and connectors\n */\nexport class DefaultEventHandlers<O = {}> extends CoreEventHandlers<\n  DefaultEventHandlersOptions & O\n> {\n  /**\n   * Note: Multiple drag shadows (ie: via multiselect in v0.2 and higher) do not look good on Linux Chromium due to way it renders drag shadows in general,\n   * so will have to fallback to the single shadow approach above for the time being\n   * see: https://bugs.chromium.org/p/chromium/issues/detail?id=550999\n   */\n  static forceSingleDragShadow = isChromium() && isLinux();\n\n  draggedElementShadow: HTMLElement;\n  dragTarget: DragTarget;\n  positioner: Positioner | null = null;\n  currentSelectedElementIds = [];\n\n  onDisable() {\n    this.options.store.actions.clearEvents();\n  }\n\n  handlers() {\n    const store = this.options.store;\n\n    return {\n      connect: (el: HTMLElement, id: NodeId) => {\n        store.actions.setDOM(id, el);\n\n        return this.reflect((connectors) => {\n          connectors.select(el, id);\n          connectors.hover(el, id);\n          connectors.drop(el, id);\n        });\n      },\n      select: (el: HTMLElement, id: NodeId) => {\n        const unbindOnMouseDown = this.addCraftEventListener(\n          el,\n          'mousedown',\n          (e) => {\n            e.craft.stopPropagation();\n\n            let newSelectedElementIds = [];\n\n            if (id) {\n              const { query } = store;\n              const selectedElementIds = query.getEvent('selected').all();\n              const isMultiSelect = this.options.isMultiSelectEnabled(e);\n\n              /**\n               * Retain the previously select elements if the multi-select condition is enabled\n               * or if the currentNode is already selected\n               *\n               * so users can just click to drag the selected elements around without holding the multi-select key\n               */\n\n              if (isMultiSelect || selectedElementIds.includes(id)) {\n                newSelectedElementIds = selectedElementIds.filter(\n                  (selectedId) => {\n                    const descendants = query\n                      .node(selectedId)\n                      .descendants(true);\n                    const ancestors = query.node(selectedId).ancestors(true);\n\n                    // Deselect ancestors/descendants\n                    if (descendants.includes(id) || ancestors.includes(id)) {\n                      return false;\n                    }\n\n                    return true;\n                  }\n                );\n              }\n\n              if (!newSelectedElementIds.includes(id)) {\n                newSelectedElementIds.push(id);\n              }\n            }\n\n            store.actions.setNodeEvent('selected', newSelectedElementIds);\n          }\n        );\n\n        const unbindOnClick = this.addCraftEventListener(el, 'click', (e) => {\n          e.craft.stopPropagation();\n\n          const { query } = store;\n          const selectedElementIds = query.getEvent('selected').all();\n\n          const isMultiSelect = this.options.isMultiSelectEnabled(e);\n          const isNodeAlreadySelected = this.currentSelectedElementIds.includes(\n            id\n          );\n\n          let newSelectedElementIds = [...selectedElementIds];\n\n          if (isMultiSelect && isNodeAlreadySelected) {\n            newSelectedElementIds.splice(newSelectedElementIds.indexOf(id), 1);\n            store.actions.setNodeEvent('selected', newSelectedElementIds);\n          } else if (!isMultiSelect && selectedElementIds.length > 1) {\n            newSelectedElementIds = [id];\n            store.actions.setNodeEvent('selected', newSelectedElementIds);\n          }\n\n          this.currentSelectedElementIds = newSelectedElementIds;\n        });\n\n        return () => {\n          unbindOnMouseDown();\n          unbindOnClick();\n        };\n      },\n      hover: (el: HTMLElement, id: NodeId) => {\n        const unbindMouseover = this.addCraftEventListener(\n          el,\n          'mouseover',\n          (e) => {\n            e.craft.stopPropagation();\n            store.actions.setNodeEvent('hovered', id);\n          }\n        );\n\n        let unbindMouseleave: (() => void) | null = null;\n\n        if (this.options.removeHoverOnMouseleave) {\n          unbindMouseleave = this.addCraftEventListener(\n            el,\n            'mouseleave',\n            (e) => {\n              e.craft.stopPropagation();\n              store.actions.setNodeEvent('hovered', null);\n            }\n          );\n        }\n\n        return () => {\n          unbindMouseover();\n\n          if (!unbindMouseleave) {\n            return;\n          }\n\n          unbindMouseleave();\n        };\n      },\n      drop: (el: HTMLElement, targetId: NodeId) => {\n        const unbindDragOver = this.addCraftEventListener(\n          el,\n          'dragover',\n          (e) => {\n            e.craft.stopPropagation();\n            e.preventDefault();\n\n            if (!this.positioner) {\n              return;\n            }\n\n            const indicator = this.positioner.computeIndicator(\n              targetId,\n              e.clientX,\n              e.clientY\n            );\n\n            if (!indicator) {\n              return;\n            }\n\n            store.actions.setIndicator(indicator);\n          }\n        );\n\n        const unbindDragEnter = this.addCraftEventListener(\n          el,\n          'dragenter',\n          (e) => {\n            e.craft.stopPropagation();\n            e.preventDefault();\n          }\n        );\n\n        return () => {\n          unbindDragEnter();\n          unbindDragOver();\n        };\n      },\n      drag: (el: HTMLElement, id: NodeId) => {\n        if (!store.query.node(id).isDraggable()) {\n          return () => {};\n        }\n\n        el.setAttribute('draggable', 'true');\n\n        const unbindDragStart = this.addCraftEventListener(\n          el,\n          'dragstart',\n          (e) => {\n            e.craft.stopPropagation();\n\n            const { query, actions } = store;\n\n            let selectedElementIds = query.getEvent('selected').all();\n\n            const isMultiSelect = this.options.isMultiSelectEnabled(e);\n            const isNodeAlreadySelected = this.currentSelectedElementIds.includes(\n              id\n            );\n\n            if (!isNodeAlreadySelected) {\n              if (isMultiSelect) {\n                selectedElementIds = [...selectedElementIds, id];\n              } else {\n                selectedElementIds = [id];\n              }\n              store.actions.setNodeEvent('selected', selectedElementIds);\n            }\n\n            actions.setNodeEvent('dragged', selectedElementIds);\n\n            const selectedDOMs = selectedElementIds.map(\n              (id) => query.node(id).get().dom\n            );\n\n            this.draggedElementShadow = createShadow(\n              e,\n              selectedDOMs,\n              DefaultEventHandlers.forceSingleDragShadow\n            );\n\n            this.dragTarget = {\n              type: 'existing',\n              nodes: selectedElementIds,\n            };\n\n            this.positioner = new Positioner(\n              this.options.store,\n              this.dragTarget\n            );\n          }\n        );\n\n        const unbindDragEnd = this.addCraftEventListener(el, 'dragend', (e) => {\n          e.craft.stopPropagation();\n\n          this.dropElement((dragTarget, indicator) => {\n            if (dragTarget.type === 'new') {\n              return;\n            }\n\n            const index =\n              indicator.placement.index +\n              (indicator.placement.where === 'after' ? 1 : 0);\n\n            store.actions.move(\n              dragTarget.nodes,\n              indicator.placement.parent.id,\n              index\n            );\n          });\n        });\n\n        return () => {\n          el.setAttribute('draggable', 'false');\n          unbindDragStart();\n          unbindDragEnd();\n        };\n      },\n      create: (\n        el: HTMLElement,\n        userElement: React.ReactElement | (() => NodeTree | React.ReactElement),\n        options?: Partial<CreateHandlerOptions>\n      ) => {\n        el.setAttribute('draggable', 'true');\n\n        const unbindDragStart = this.addCraftEventListener(\n          el,\n          'dragstart',\n          (e) => {\n            e.craft.stopPropagation();\n            let tree;\n            if (typeof userElement === 'function') {\n              const result = userElement();\n              if (React.isValidElement(result)) {\n                tree = store.query.parseReactElement(result).toNodeTree();\n              } else {\n                tree = result;\n              }\n            } else {\n              tree = store.query.parseReactElement(userElement).toNodeTree();\n            }\n\n            const dom = e.currentTarget as HTMLElement;\n            this.draggedElementShadow = createShadow(\n              e,\n              [dom],\n              DefaultEventHandlers.forceSingleDragShadow\n            );\n            this.dragTarget = {\n              type: 'new',\n              tree,\n            };\n\n            this.positioner = new Positioner(\n              this.options.store,\n              this.dragTarget\n            );\n          }\n        );\n\n        const unbindDragEnd = this.addCraftEventListener(el, 'dragend', (e) => {\n          e.craft.stopPropagation();\n          this.dropElement((dragTarget, indicator) => {\n            if (dragTarget.type === 'existing') {\n              return;\n            }\n\n            const index =\n              indicator.placement.index +\n              (indicator.placement.where === 'after' ? 1 : 0);\n            store.actions.addNodeTree(\n              dragTarget.tree,\n              indicator.placement.parent.id,\n              index\n            );\n\n            if (options && isFunction(options.onCreate)) {\n              options.onCreate(dragTarget.tree);\n            }\n          });\n        });\n\n        return () => {\n          el.removeAttribute('draggable');\n          unbindDragStart();\n          unbindDragEnd();\n        };\n      },\n    };\n  }\n\n  private dropElement(\n    onDropNode: (dragTarget: DragTarget, placement: Indicator) => void\n  ) {\n    const store = this.options.store;\n\n    if (!this.positioner) {\n      return;\n    }\n\n    const draggedElementShadow = this.draggedElementShadow;\n\n    const indicator = this.positioner.getIndicator();\n\n    if (this.dragTarget && indicator && !indicator.error) {\n      onDropNode(this.dragTarget, indicator);\n    }\n\n    if (draggedElementShadow) {\n      draggedElementShadow.parentNode.removeChild(draggedElementShadow);\n      this.draggedElementShadow = null;\n    }\n\n    this.dragTarget = null;\n\n    store.actions.setIndicator(null);\n    store.actions.setNodeEvent('dragged', null);\n    this.positioner.cleanup();\n\n    this.positioner = null;\n  }\n}\n","import { RenderIndicator, getDOMInfo } from '@craftjs/utils';\nimport React, { useEffect } from 'react';\n\nimport { useEventHandler } from './EventContext';\nimport movePlaceholder from './movePlaceholder';\n\nimport { useInternalEditor } from '../editor/useInternalEditor';\n\nexport const RenderEditorIndicator = () => {\n  const { indicator, indicatorOptions, enabled } = useInternalEditor(\n    (state) => ({\n      indicator: state.indicator,\n      indicatorOptions: state.options.indicator,\n      enabled: state.options.enabled,\n    })\n  );\n\n  const handler = useEventHandler();\n\n  useEffect(() => {\n    if (!handler) {\n      return;\n    }\n\n    if (!enabled) {\n      handler.disable();\n      return;\n    }\n\n    handler.enable();\n  }, [enabled, handler]);\n\n  if (!indicator) {\n    return null;\n  }\n\n  const placeholderInfo = movePlaceholder(\n    indicator.placement,\n    getDOMInfo(indicator.placement.parent.dom),\n    indicator.placement.currentNode &&\n      getDOMInfo(indicator.placement.currentNode.dom),\n    indicatorOptions.thickness\n  );\n\n  const isBlockMode = placeholderInfo.mode === 'block';\n  const baseColor = indicator.error\n    ? indicatorOptions.error\n    : indicatorOptions.success;\n\n  return (\n    <RenderIndicator\n      className={indicatorOptions.className}\n      style={{\n        top: placeholderInfo.top,\n        left: placeholderInfo.left,\n        width: placeholderInfo.width,\n        height: placeholderInfo.height,\n        // Apply different styles based on mode\n        ...(isBlockMode\n          ? {\n              // Block area styles - subtle outline with corner accents\n              backgroundColor: `${baseColor}08`, // 08 = ~3% opacity (very subtle)\n              border: `2px solid ${baseColor}`,\n              borderRadius: '6px',\n              boxSizing: 'border-box',\n              pointerEvents: 'none',\n              // Add subtle shadow for depth\n              boxShadow: `0 0 0 4px ${baseColor}10, inset 0 0 20px ${baseColor}15`,\n              // Smooth transition\n              transition: 'all 0.2s cubic-bezier(0.4, 0, 0.2, 1)',\n            }\n          : {\n              // Line styles (existing behavior)\n              backgroundColor: baseColor,\n              borderWidth: 0,\n            }),\n        transition: indicatorOptions.transition || '0.2s ease-in',\n        ...(indicatorOptions.style ?? {}),\n      }}\n      parentDom={indicator.placement.parent.dom}\n    />\n  );\n};\n","import { DropPosition, DOMInfo } from '../interfaces';\n\nexport default function movePlaceholder(\n  pos: DropPosition,\n  canvasDOMInfo: DOMInfo, // which canvas is cursor at\n  bestTargetDomInfo: DOMInfo | null, // closest element in canvas (null if canvas is empty)\n  thickness: number = 2\n): {\n  top: string;\n  left: string;\n  width: string;\n  height: string;\n  mode: 'line' | 'block';\n} {\n  let t = 0,\n    l = 0,\n    w = 0,\n    h = 0,\n    where = pos.where;\n\n  let mode: 'line' | 'block' = 'line';\n  const elDim = bestTargetDomInfo;\n\n  // Show block area for empty containers or when dropping into container\n  if (!elDim) {\n    mode = 'block';\n    if (canvasDOMInfo) {\n      t = canvasDOMInfo.top + canvasDOMInfo.padding.top;\n      l = canvasDOMInfo.left + canvasDOMInfo.padding.left;\n      w =\n        canvasDOMInfo.outerWidth -\n        canvasDOMInfo.padding.right -\n        canvasDOMInfo.padding.left -\n        canvasDOMInfo.margin.left -\n        canvasDOMInfo.margin.right;\n      h =\n        canvasDOMInfo.outerHeight -\n        canvasDOMInfo.padding.top -\n        canvasDOMInfo.padding.bottom -\n        canvasDOMInfo.margin.top -\n        canvasDOMInfo.margin.bottom;\n\n      // Minimum height for better visibility\n      h = Math.max(h, 40);\n    }\n  } else {\n    // Line indicator for before/after\n    mode = 'line';\n    // If it's not in flow (like 'float' element)\n    if (!elDim.inFlow) {\n      w = thickness;\n      h = elDim.outerHeight;\n      t = elDim.top;\n      l = where === 'before' ? elDim.left : elDim.left + elDim.outerWidth;\n    } else {\n      w = elDim.outerWidth;\n      h = thickness;\n      t = where === 'before' ? elDim.top : elDim.bottom;\n      l = elDim.left;\n    }\n  }\n\n  return {\n    top: `${t}px`,\n    left: `${l}px`,\n    width: `${w}px`,\n    height: `${h}px`,\n    mode,\n  };\n}\n","import React from 'react';\n\nimport { useInternalEditor } from '../editor/useInternalEditor';\n\nconst GUIDE_COLOR = '#0096FF';\nconst GUIDE_WIDTH = 1;\n\n/**\n * RenderSnapGuides renders visual alignment guide lines during drag operations\n */\nexport const RenderSnapGuides = () => {\n  const { snapGuides, enabled } = useInternalEditor((state) => ({\n    snapGuides: state.snapGuides || [],\n    enabled: state.options.enabled,\n  }));\n\n  if (!enabled || !snapGuides || snapGuides.length === 0) {\n    return null;\n  }\n\n  return (\n    <>\n      {snapGuides.map((guide, index) => {\n        const isHorizontal = guide.type === 'horizontal';\n\n        const style: React.CSSProperties = {\n          position: 'fixed',\n          backgroundColor: GUIDE_COLOR,\n          pointerEvents: 'none',\n          zIndex: 99999,\n          ...(isHorizontal\n            ? {\n                left: guide.start,\n                top: guide.position - GUIDE_WIDTH / 2,\n                width: guide.end - guide.start,\n                height: GUIDE_WIDTH,\n              }\n            : {\n                left: guide.position - GUIDE_WIDTH / 2,\n                top: guide.start,\n                width: GUIDE_WIDTH,\n                height: guide.end - guide.start,\n              }),\n        };\n\n        return <div key={`snap-guide-${index}`} style={style} />;\n      })}\n    </>\n  );\n};\n","import React, { useContext, useMemo } from 'react';\n\nimport { EventHandlerContext } from './EventContext';\nimport { RenderEditorIndicator } from './RenderEditorIndicator';\nimport { RenderSnapGuides } from './RenderSnapGuides';\n\nimport { EditorContext } from '../editor/EditorContext';\n\ntype EventsProps = {\n  children?: React.ReactNode;\n};\n\nexport const Events = ({ children }: EventsProps) => {\n  const store = useContext(EditorContext);\n\n  const handler = useMemo(() => store.query.getOptions().handlers(store), [\n    store,\n  ]);\n\n  if (!handler) {\n    return null;\n  }\n\n  return (\n    <EventHandlerContext.Provider value={handler}>\n      <RenderEditorIndicator />\n      <RenderSnapGuides />\n      {children}\n    </EventHandlerContext.Provider>\n  );\n};\n","import {\n  useMethods,\n  SubscriberAndCallbacksFor,\n  PatchListener,\n} from '@craftjs/utils';\n\nimport { ActionMethods } from './actions';\nimport { QueryMethods } from './query';\n\nimport { DefaultEventHandlers } from '../events';\nimport { EditorState, Options, NodeEventTypes, NodeId } from '../interfaces';\n\nexport const editorInitialState: EditorState = {\n  nodes: {},\n  events: {\n    dragged: new Set<NodeId>(),\n    selected: new Set<NodeId>(),\n    hovered: new Set<NodeId>(),\n  },\n  indicator: null,\n  snapGuides: [],\n  options: {\n    onNodesChange: () => null,\n    onRender: ({ render }) => render,\n    onBeforeMoveEnd: () => null,\n    resolver: {},\n    enabled: true,\n    indicator: {\n      error: 'red',\n      success: 'rgb(98, 196, 98)',\n    },\n    handlers: (store) =>\n      new DefaultEventHandlers({\n        store,\n        removeHoverOnMouseleave: false,\n        isMultiSelectEnabled: (e: MouseEvent) => !!e.metaKey,\n      }),\n    normalizeNodes: () => {},\n  },\n};\n\nexport const ActionMethodsWithConfig = {\n  methods: ActionMethods,\n  ignoreHistoryForActions: [\n    'setDOM',\n    'setNodeEvent',\n    'selectNode',\n    'clearEvents',\n    'setOptions',\n    'setIndicator',\n    'setSnapGuides',\n  ] as const,\n  normalizeHistory: (state: EditorState) => {\n    /**\n     * On every undo/redo, we remove events pointing to deleted Nodes\n     */\n    Object.keys(state.events).forEach((eventName: NodeEventTypes) => {\n      const nodeIds = Array.from(state.events[eventName] || []);\n\n      nodeIds.forEach((id) => {\n        if (!state.nodes[id]) {\n          state.events[eventName].delete(id);\n        }\n      });\n    });\n\n    // Remove any invalid node[nodeId].events\n    // TODO(prev): it's really cumbersome to have to ensure state.events and state.nodes[nodeId].events are in sync\n    // Find a way to make it so that once state.events is set, state.nodes[nodeId] automatically reflects that (maybe using proxies?)\n    Object.keys(state.nodes).forEach((id) => {\n      const node = state.nodes[id];\n\n      Object.keys(node.events).forEach((eventName: NodeEventTypes) => {\n        const isEventActive = !!node.events[eventName];\n\n        if (\n          isEventActive &&\n          state.events[eventName] &&\n          !state.events[eventName].has(node.id)\n        ) {\n          node.events[eventName] = false;\n        }\n      });\n    });\n  },\n};\n\nexport type EditorStore = SubscriberAndCallbacksFor<\n  typeof ActionMethodsWithConfig,\n  typeof QueryMethods\n>;\n\nexport const useEditorStore = (\n  options: Partial<Options>,\n  patchListener: PatchListener<\n    EditorState,\n    typeof ActionMethodsWithConfig,\n    typeof QueryMethods\n  >\n): EditorStore => {\n  // TODO: fix type\n  return useMethods(\n    ActionMethodsWithConfig,\n    {\n      ...editorInitialState,\n      options: {\n        ...editorInitialState.options,\n        ...options,\n      },\n    },\n    QueryMethods,\n    patchListener\n  ) as EditorStore;\n};\n","import cloneDeep from 'lodash/cloneDeep';\n\nimport { createNode } from './createNode';\n\nimport { editorInitialState } from '../editor/store';\nimport { Nodes } from '../interfaces';\n\nconst getTestNode = (parentNode) => {\n  const {\n    events,\n    data: { nodes: childNodes, linkedNodes },\n    ...restParentNode\n  } = parentNode;\n  const validParentNode = createNode(cloneDeep(parentNode));\n  parentNode = {\n    ...validParentNode,\n    ...restParentNode,\n    events: {\n      ...validParentNode.events,\n      ...events,\n    },\n    dom: parentNode.dom || validParentNode.dom,\n  };\n\n  return {\n    node: parentNode,\n    childNodes,\n    linkedNodes,\n  };\n};\n\nexport const expectEditorState = (lhs, rhs) => {\n  const { nodes: nodesRhs, ...restRhs } = rhs;\n  const { nodes: nodesLhs, ...restLhs } = lhs;\n  expect(restLhs).toEqual(restRhs);\n\n  const nodesRhsSimplified = Object.keys(nodesRhs).reduce((accum, id) => {\n    const { _hydrationTimestamp, rules, ...node } = nodesRhs[id];\n    accum[id] = node;\n    return accum;\n  }, {});\n\n  const nodesLhsSimplified = Object.keys(nodesLhs).reduce((accum, id) => {\n    const { _hydrationTimestamp, rules, ...node } = nodesLhs[id];\n    accum[id] = node;\n    return accum;\n  }, {});\n\n  expect(nodesLhsSimplified).toEqual(nodesRhsSimplified);\n};\n\nexport const createTestNodes = (rootNode): Nodes => {\n  const nodes = {};\n  const iterateNodes = (testNode) => {\n    const { node: parentNode, childNodes, linkedNodes } = getTestNode(testNode);\n    nodes[parentNode.id] = parentNode;\n\n    if (childNodes) {\n      childNodes.forEach((childTestNode, i) => {\n        const {\n          node: childNode,\n          childNodes: grandChildNodes,\n          linkedNodes: grandChildLinkedNodes,\n        } = getTestNode(childTestNode);\n        childNode.data.parent = parentNode.id;\n        nodes[childNode.id] = childNode;\n        parentNode.data.nodes[i] = childNode.id;\n        iterateNodes({\n          ...childNode,\n          data: {\n            ...childNode.data,\n            nodes: grandChildNodes || [],\n            linkedNodes: grandChildLinkedNodes || {},\n          },\n        });\n      });\n    }\n\n    if (linkedNodes) {\n      Object.keys(linkedNodes).forEach((linkedId) => {\n        const {\n          node: childNode,\n          childNodes: grandChildNodes,\n          linkedNodes: grandChildLinkedNodes,\n        } = getTestNode(linkedNodes[linkedId]);\n        parentNode.data.linkedNodes[linkedId] = childNode.id;\n\n        childNode.data.parent = parentNode.id;\n        nodes[childNode.id] = childNode;\n        iterateNodes({\n          ...childNode,\n          data: {\n            ...childNode.data,\n            nodes: grandChildNodes || [],\n            linkedNodes: grandChildLinkedNodes || {},\n          },\n        });\n      });\n    }\n  };\n\n  iterateNodes(rootNode);\n\n  return nodes;\n};\n\nexport const createTestState = (state = {} as any) => {\n  const { nodes: rootNode, events } = state;\n\n  return {\n    ...editorInitialState,\n    ...state,\n    nodes: rootNode ? createTestNodes(rootNode) : {},\n    events: {\n      ...editorInitialState.events,\n      ...(events || {}),\n    },\n  };\n};\n","import { ERROR_RESOLVER_NOT_AN_OBJECT, HISTORY_ACTIONS } from '@craftjs/utils';\nimport * as React from 'react';\nimport invariant from 'tiny-invariant';\n\nimport { EditorContext } from './EditorContext';\nimport { useEditorStore } from './store';\n\nimport { Events } from '../events';\nimport { Options } from '../interfaces';\n\ntype EditorProps = Partial<Options> & {\n  children?: React.ReactNode;\n};\n\n/**\n * A React Component that provides the Editor context\n */\nexport const Editor = ({ children, ...options }: EditorProps) => {\n  // we do not want to warn the user if no resolver was supplied\n  if (options.resolver !== undefined) {\n    invariant(\n      typeof options.resolver === 'object' &&\n        !Array.isArray(options.resolver) &&\n        options.resolver !== null,\n      ERROR_RESOLVER_NOT_AN_OBJECT\n    );\n  }\n\n  const optionsRef = React.useRef(options);\n\n  const context = useEditorStore(\n    optionsRef.current,\n    (state, previousState, actionPerformedWithPatches, query, normalizer) => {\n      if (!actionPerformedWithPatches) {\n        return;\n      }\n\n      const { patches, ...actionPerformed } = actionPerformedWithPatches;\n\n      for (let i = 0; i < patches.length; i++) {\n        const { path } = patches[i];\n        const isModifyingNodeData =\n          path.length > 2 && path[0] === 'nodes' && path[2] === 'data';\n\n        let actionType = actionPerformed.type;\n\n        if (\n          [HISTORY_ACTIONS.IGNORE, HISTORY_ACTIONS.THROTTLE].includes(\n            actionType\n          ) &&\n          actionPerformed.params\n        ) {\n          actionPerformed.type = actionPerformed.params[0];\n        }\n\n        if (\n          ['setState', 'deserialize'].includes(actionPerformed.type) ||\n          isModifyingNodeData\n        ) {\n          normalizer((draft) => {\n            if (state.options.normalizeNodes) {\n              state.options.normalizeNodes(\n                draft,\n                previousState,\n                actionPerformed,\n                query\n              );\n            }\n          });\n          break; // we exit the loop as soon as we find a change in node.data\n        }\n      }\n    }\n  );\n\n  // sync enabled prop with editor store options\n  React.useEffect(() => {\n    if (!context) {\n      return;\n    }\n\n    if (\n      options.enabled === undefined ||\n      context.query.getOptions().enabled === options.enabled\n    ) {\n      return;\n    }\n\n    context.actions.setOptions((editorOptions) => {\n      editorOptions.enabled = options.enabled;\n    });\n  }, [context, options.enabled]);\n\n  React.useEffect(() => {\n    context.subscribe(\n      (_) => ({\n        json: context.query.serialize(),\n      }),\n      () => {\n        context.query.getOptions().onNodesChange(context.query);\n      }\n    );\n  }, [context]);\n\n  if (!context) {\n    return null;\n  }\n\n  return (\n    <EditorContext.Provider value={context}>\n      <Events>{children}</Events>\n    </EditorContext.Provider>\n  );\n};\n","import React from 'react';\n\nimport { EditorState } from '../../interfaces';\nimport { useEditor } from '../useEditor';\n\nexport function connectEditor<C>(collect?: (state: EditorState) => C) {\n  return (WrappedComponent: React.ElementType) => {\n    return (props: any) => {\n      const Editor = collect ? useEditor(collect) : useEditor();\n      return <WrappedComponent {...Editor} {...props} />;\n    };\n  };\n}\n","import React from 'react';\n\nimport { Node } from '../../interfaces';\nimport { useNode } from '../useNode';\n\nexport function connectNode<C>(collect?: (state: Node) => C) {\n  return function (WrappedComponent: React.ElementType) {\n    return (props: any) => {\n      const node = useNode(collect);\n      return <WrappedComponent {...node} {...props} />;\n    };\n  };\n}\n"],"names":["NodeContext","React","createContext","NodeProvider","id","related","children","createElement","Provider","value","EditorContext","EventHandlerContext","useEventHandler","useContext","useInternalEditor","collector","handler","store","invariant","ERROR_USE_EDITOR_OUTSIDE_OF_EDITOR_CONTEXT","collected","useCollector","connectorsUsage","useMemo","createConnectorsUsage","useEffect","register","cleanup","connectors","wrapConnectorHooks","_objectSpread","inContext","useInternalNode","collect","context","ERROR_USE_NODE_OUTSIDE_OF_EDITOR_CONTEXT","_useInternalEditor","state","nodes","actions","EditorActions","editorConnectors","_objectWithoutProperties","_excluded","connect","dom","drag","setProp","cb","throttleRate","history","throttle","setCustom","setHidden","bool","inNodeContext","useNode","_useInternalNode","deprecationWarning","suggest","SimpleElement","render","type","cloneElement","DefaultRender","props","hydrationTimestamp","node","data","_hydrationTimestamp","length","Fragment","map","NodeElement","key","RenderNodeToElement","hidden","onRender","options","defaultElementProps","is","canvas","custom","elementPropToNodeData","Element","elementProps","query","nodeId","linkedNodeId","useState","ERROR_TOP_LEVEL_ELEMENT_NO_ID","get","existingNode","linkedNodes","linkedElement","tree","parseReactElement","toNodeTree","ignore","addLinkedNodeFromTree","rootNodeId","deprecateCanvasComponent","Canvas","RenderRootNode","timestamp","ROOT_NODE","NodeSelectorType","getPublicActions","setDOM","setNodeEvent","replaceNodes","reset","useEditor","internalActions","args","fromEntries","pairs","Object","reduce","accum","_ref","getNodesFromSelector","selector","config","items","Array","isArray","mergedConfig","existOnly","idOnly","nodeSelectors","filter","item","exists","ERROR_INVALID_NODEID","Methods","addNodeTreeToParent","parentId","addNodeType","iterateChildren","resolver","name","ERROR_NOT_IN_RESOLVER","replace","concat","parent","forEach","childNodeId","values","getParentAndValidate","index","splice","push","ERROR_NOPARENT","deleteNode","targetNode","parentNode","childId","includes","parentChildren","indexOf","linkedId","keys","find","removeNodeFromEvents","events","eventSet","has","Set","from","existingLinkedNode","add","nodeToAdd","addNodeTree","delete","isTopLevelNode","ERROR_DELETE_TOP_LEVEL_NODE","deserialize","input","dehydratedNodes","JSON","parse","nodePairs","DEPRECATED_ROOT_NODE","parseSerializedNode","toNode","this","move","newParentId","targets","newParent","nodesArrToCleanup","_ref2","i","targetId","currentParentId","isDroppable","err","Error","onBeforeMoveEnd","currentParentNodes","oldIndex","reverse","clearEvents","setIndicator","setOptions","eventType","nodeIdSelector","nodeIds","_ref3","_ref4","indicator","placement","currentNode","setSnapGuides","guides","snapGuides","_ref5","selectNode","_ref6","CACHED_RESOLVER_DATA","resolveComponent","comp","resolvedName","searchComponentInResolver","reversed","Map","entries","set","getReversedResolver","undefined","component","displayName","reduceType","serializeComp","isCanvas","result","prop","Children","child","serializeNode","nodeData","NodeHelpers","ERROR_INVALID_NODE_ID","nodeHelpers","isRoot","isLinkedNode","isDeletable","isParentOfTopLevelNodes","isParentOfTopLevelCanvas","isSelected","selected","isHovered","hovered","isDragged","dragged","ancestors","deep","arguments","appendParentNode","depth","descendants","includeOnly","appendChildNode","childNodes","isDraggable","onError","ERROR_MOVE_TOP_LEVEL_NODE","ERROR_MOVE_NONCANVAS_CHILD","rules","canDrag","ERROR_CANNOT_DRAG","newParentNode","ERROR_MOVE_TO_NONCANVAS_PARENT","canMoveIn","ERROR_MOVE_INCOMING_PARENT","parentNodes","canDrop","ERROR_MOVE_CANNOT_DROP","targetDeepNodes","ERROR_MOVE_TO_DESCENDANT","currentParentNode","ERROR_DUPLICATE_NODEID","parentNodeId","canMoveOut","ERROR_MOVE_OUTGOING_PARENT","toSerializedNode","descendantId","decendants","isTopLevelCanvas","findPosition","dims","posX","posY","where","leftLimit","xLimit","dimRight","yLimit","xCenter","yCenter","dimDown","len","dim","left","outerWidth","top","outerHeight","inFlow","getNodeTypeName","createNode","newNode","normalize","actualType","getRandomNodeId","getRandomId","Date","now","info","mergedProps","userComponentConfig","craft","defaultProps","relatedNodeContext","deserializeComp","main","restoreType","jsx","mergeNodes","rootNode","childrenNodes","nodeWithChildren","QueryMethods","_","getDropPlaceholder","source","target","pos","nodesToDOM","targetParent","targetParentNodes","dropAction","getDOMInfo","x","y","output","error","getOptions","getNodes","getSerializedNodes","getEvent","event","contains","isEmpty","all","first","last","size","at","raw","EventHelpers","serialize","stringify","reactElement","element","parseNodeFromJSX","toArray","isValidElement","mergeTrees","serializedNode","Comp","Props","ERROR_DESERIALIZE_COMPONENT_NOT_IN_RESOLVER","join","_childCanvas","deserializeNode","parseFreshNode","extras","getState","CoreEventHandlers","EventHandlers","handlers","el","select","hover","drop","create","UserElement","SnapGuideCalculator","constructor","_defineProperty","setSiblings","excludeIds","canvasBounds","getBoundingClientRect","siblingDimensions","Boolean","calculate","draggedRect","snapX","snapY","draggedCenterX","width","draggedCenterY","height","sibling","siblingCenterX","siblingCenterY","Math","abs","SNAP_THRESHOLD","position","start","min","end","max","bottom","right","canvasCenterX","canvasCenterY","deduplicateGuides","seen","guide","round","existing","clear","documentDragoverEventHandler","e","preventDefault","Positioner","dragTarget","currentDropTargetId","currentDropTargetCanvasAncestorId","currentTargetId","currentTargetChildDimensions","currentIndicator","dragError","draggedNodes","getDraggedNodes","validateDraggedNodes","snapGuideCalculator","onScrollListener","onScroll","bind","window","addEventListener","removeEventListener","scrollBody","isNearBorders","domInfo","BORDER_OFFSET","isDiff","newPosition","getChildDimensions","existingTargetChildDimensions","getCanvasAncestor","dropTargetId","getCanvas","computeIndicator","sourceNode","dropError","currentNodeId","draggedNodeIds","n","snapResult","getIndicator","createShadow","shadowsToCreate","shadow","cloneNode","style","pointerEvents","classList","document","body","appendChild","dataTransfer","setDragImage","container","clientX","clientY","DefaultEventHandlers","super","onDisable","reflect","unbindOnMouseDown","addCraftEventListener","stopPropagation","newSelectedElementIds","selectedElementIds","isMultiSelectEnabled","selectedId","unbindOnClick","isMultiSelect","isNodeAlreadySelected","currentSelectedElementIds","unbindMouseover","unbindMouseleave","removeHoverOnMouseleave","unbindDragOver","positioner","unbindDragEnter","setAttribute","unbindDragStart","selectedDOMs","draggedElementShadow","forceSingleDragShadow","unbindDragEnd","dropElement","userElement","currentTarget","isFunction","onCreate","removeAttribute","onDropNode","removeChild","isChromium","isLinux","RenderEditorIndicator","indicatorOptions","enabled","enable","disable","placeholderInfo","canvasDOMInfo","bestTargetDomInfo","thickness","t","l","w","h","mode","padding","margin","movePlaceholder","baseColor","success","RenderIndicator","className","backgroundColor","border","borderRadius","boxSizing","boxShadow","transition","borderWidth","parentDom","RenderSnapGuides","zIndex","GUIDE_WIDTH","Events","editorInitialState","onNodesChange","metaKey","normalizeNodes","ActionMethodsWithConfig","methods","ActionMethods","setState","_this","ignoreHistoryForActions","normalizeHistory","eventName","useEditorStore","patchListener","useMethods","getTestNode","restParentNode","validParentNode","cloneDeep","createTestNodes","iterateNodes","testNode","childTestNode","childNode","grandChildNodes","grandChildLinkedNodes","DerivedEventHandlers","ERROR_RESOLVER_NOT_AN_OBJECT","optionsRef","useRef","current","previousState","actionPerformedWithPatches","normalizer","patches","actionPerformed","path","isModifyingNodeData","HISTORY_ACTIONS","IGNORE","THROTTLE","params","draft","editorOptions","subscribe","json","isLoaded","initialData","only","WrappedComponent","Editor","expectEditorState","lhs","rhs","nodesRhs","restRhs","_excluded2","nodesLhs","restLhs","_excluded3","expect","toEqual","nodesRhsSimplified","_excluded4","nodesLhsSimplified","_excluded5"],"mappings":"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"}