{"version":3,"file":"SnapGuideCalculator.js","sourceRoot":"","sources":["../../src/events/SnapGuideCalculator.ts"],"names":[],"mappings":"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","sourcesContent":["import { getDOMInfo } from '@craftjs/utils';\n\nimport { EditorStore } from '../editor/store';\nimport { NodeId, NodeInfo } from '../interfaces';\n\nexport interface SnapGuide {\n  type: 'horizontal' | 'vertical';\n  position: number; // y position for horizontal, x position for vertical\n  start: number; // start x for horizontal, start y for vertical\n  end: number; // end x for horizontal, end y for vertical\n}\n\nexport interface SnapResult {\n  guides: SnapGuide[];\n  snapX: number | null; // snapped x position (or null if no snap)\n  snapY: number | null; // snapped y position (or null if no snap)\n}\n\n/**\n * SnapGuideCalculator computes alignment guides during drag operations\n * Option A: Basic center-line snapping only\n */\nexport class SnapGuideCalculator {\n  static SNAP_THRESHOLD = 8; // pixels within which to snap\n\n  private siblingDimensions: NodeInfo[] = [];\n  private canvasBounds: DOMRect | null = null;\n\n  constructor(readonly store: EditorStore) {}\n\n  /**\n   * Initialize with sibling elements to snap against\n   */\n  setSiblings(parentId: NodeId, excludeIds: NodeId[]) {\n    const parentNode = this.store.query.node(parentId).get();\n    if (!parentNode) return;\n\n    // Get canvas/parent bounds\n    if (parentNode.dom) {\n      this.canvasBounds = parentNode.dom.getBoundingClientRect();\n    }\n\n    // Get all sibling dimensions except the ones being dragged\n    this.siblingDimensions = parentNode.data.nodes\n      .filter((id) => !excludeIds.includes(id))\n      .map((id) => {\n        const node = this.store.query.node(id).get();\n        if (!node || !node.dom) return null;\n        return {\n          id,\n          ...getDOMInfo(node.dom),\n        };\n      })\n      .filter(Boolean) as NodeInfo[];\n  }\n\n  /**\n   * Calculate snap guides based on current drag position\n   */\n  calculate(draggedRect: DOMRect): SnapResult {\n    const guides: SnapGuide[] = [];\n    let snapX: number | null = null;\n    let snapY: number | null = null;\n\n    const draggedCenterX = draggedRect.left + draggedRect.width / 2;\n    const draggedCenterY = draggedRect.top + draggedRect.height / 2;\n\n    // Check alignment with each sibling\n    for (const sibling of this.siblingDimensions) {\n      const siblingCenterX = sibling.left + sibling.width / 2;\n      const siblingCenterY = sibling.top + sibling.height / 2;\n\n      // Vertical center alignment (creates a vertical guide line)\n      const diffX = Math.abs(draggedCenterX - siblingCenterX);\n      if (diffX < SnapGuideCalculator.SNAP_THRESHOLD) {\n        snapX = siblingCenterX - draggedRect.width / 2;\n        guides.push({\n          type: 'vertical',\n          position: siblingCenterX,\n          start: Math.min(draggedRect.top, sibling.top),\n          end: Math.max(draggedRect.bottom, sibling.bottom),\n        });\n      }\n\n      // Horizontal center alignment (creates a horizontal guide line)\n      const diffY = Math.abs(draggedCenterY - siblingCenterY);\n      if (diffY < SnapGuideCalculator.SNAP_THRESHOLD) {\n        snapY = siblingCenterY - draggedRect.height / 2;\n        guides.push({\n          type: 'horizontal',\n          position: siblingCenterY,\n          start: Math.min(draggedRect.left, sibling.left),\n          end: Math.max(draggedRect.right, sibling.right),\n        });\n      }\n    }\n\n    // Also check alignment with canvas center\n    if (this.canvasBounds) {\n      const canvasCenterX =\n        this.canvasBounds.left + this.canvasBounds.width / 2;\n      const canvasCenterY =\n        this.canvasBounds.top + this.canvasBounds.height / 2;\n\n      const diffCanvasX = Math.abs(draggedCenterX - canvasCenterX);\n      if (diffCanvasX < SnapGuideCalculator.SNAP_THRESHOLD) {\n        snapX = canvasCenterX - draggedRect.width / 2;\n        guides.push({\n          type: 'vertical',\n          position: canvasCenterX,\n          start: this.canvasBounds.top,\n          end: this.canvasBounds.bottom,\n        });\n      }\n\n      const diffCanvasY = Math.abs(draggedCenterY - canvasCenterY);\n      if (diffCanvasY < SnapGuideCalculator.SNAP_THRESHOLD) {\n        snapY = canvasCenterY - draggedRect.height / 2;\n        guides.push({\n          type: 'horizontal',\n          position: canvasCenterY,\n          start: this.canvasBounds.left,\n          end: this.canvasBounds.right,\n        });\n      }\n    }\n\n    // Deduplicate guides (same position)\n    const uniqueGuides = this.deduplicateGuides(guides);\n\n    return {\n      guides: uniqueGuides,\n      snapX,\n      snapY,\n    };\n  }\n\n  private deduplicateGuides(guides: SnapGuide[]): SnapGuide[] {\n    const seen = new Map<string, SnapGuide>();\n\n    for (const guide of guides) {\n      const key = `${guide.type}-${Math.round(guide.position)}`;\n      const existing = seen.get(key);\n\n      if (!existing) {\n        seen.set(key, guide);\n      } else {\n        // Extend the existing guide\n        existing.start = Math.min(existing.start, guide.start);\n        existing.end = Math.max(existing.end, guide.end);\n      }\n    }\n\n    return Array.from(seen.values());\n  }\n\n  clear() {\n    this.siblingDimensions = [];\n    this.canvasBounds = null;\n  }\n}\n"]}